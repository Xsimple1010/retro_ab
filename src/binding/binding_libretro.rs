#![allow(dead_code,non_snake_case,non_camel_case_types,non_upper_case_globals)]

/* automatically generated by rust-bindgen 0.69.2 */

pub const RETRO_API_VERSION: u32 = 1;
pub const RETRO_DEVICE_TYPE_SHIFT: u32 = 8;
pub const RETRO_DEVICE_MASK: u32 = 255;
pub const RETRO_DEVICE_NONE: u32 = 0;
pub const RETRO_DEVICE_JOYPAD: u32 = 1;
pub const RETRO_DEVICE_MOUSE: u32 = 2;
pub const RETRO_DEVICE_KEYBOARD: u32 = 3;
pub const RETRO_DEVICE_LIGHTGUN: u32 = 4;
pub const RETRO_DEVICE_ANALOG: u32 = 5;
pub const RETRO_DEVICE_POINTER: u32 = 6;
pub const RETRO_DEVICE_ID_JOYPAD_B: u32 = 0;
pub const RETRO_DEVICE_ID_JOYPAD_Y: u32 = 1;
pub const RETRO_DEVICE_ID_JOYPAD_SELECT: u32 = 2;
pub const RETRO_DEVICE_ID_JOYPAD_START: u32 = 3;
pub const RETRO_DEVICE_ID_JOYPAD_UP: u32 = 4;
pub const RETRO_DEVICE_ID_JOYPAD_DOWN: u32 = 5;
pub const RETRO_DEVICE_ID_JOYPAD_LEFT: u32 = 6;
pub const RETRO_DEVICE_ID_JOYPAD_RIGHT: u32 = 7;
pub const RETRO_DEVICE_ID_JOYPAD_A: u32 = 8;
pub const RETRO_DEVICE_ID_JOYPAD_X: u32 = 9;
pub const RETRO_DEVICE_ID_JOYPAD_L: u32 = 10;
pub const RETRO_DEVICE_ID_JOYPAD_R: u32 = 11;
pub const RETRO_DEVICE_ID_JOYPAD_L2: u32 = 12;
pub const RETRO_DEVICE_ID_JOYPAD_R2: u32 = 13;
pub const RETRO_DEVICE_ID_JOYPAD_L3: u32 = 14;
pub const RETRO_DEVICE_ID_JOYPAD_R3: u32 = 15;
pub const RETRO_DEVICE_ID_JOYPAD_MASK: u32 = 256;
pub const RETRO_DEVICE_INDEX_ANALOG_LEFT: u32 = 0;
pub const RETRO_DEVICE_INDEX_ANALOG_RIGHT: u32 = 1;
pub const RETRO_DEVICE_INDEX_ANALOG_BUTTON: u32 = 2;
pub const RETRO_DEVICE_ID_ANALOG_X: u32 = 0;
pub const RETRO_DEVICE_ID_ANALOG_Y: u32 = 1;
pub const RETRO_DEVICE_ID_MOUSE_X: u32 = 0;
pub const RETRO_DEVICE_ID_MOUSE_Y: u32 = 1;
pub const RETRO_DEVICE_ID_MOUSE_LEFT: u32 = 2;
pub const RETRO_DEVICE_ID_MOUSE_RIGHT: u32 = 3;
pub const RETRO_DEVICE_ID_MOUSE_WHEELUP: u32 = 4;
pub const RETRO_DEVICE_ID_MOUSE_WHEELDOWN: u32 = 5;
pub const RETRO_DEVICE_ID_MOUSE_MIDDLE: u32 = 6;
pub const RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELUP: u32 = 7;
pub const RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELDOWN: u32 = 8;
pub const RETRO_DEVICE_ID_MOUSE_BUTTON_4: u32 = 9;
pub const RETRO_DEVICE_ID_MOUSE_BUTTON_5: u32 = 10;
pub const RETRO_DEVICE_ID_LIGHTGUN_SCREEN_X: u32 = 13;
pub const RETRO_DEVICE_ID_LIGHTGUN_SCREEN_Y: u32 = 14;
pub const RETRO_DEVICE_ID_LIGHTGUN_IS_OFFSCREEN: u32 = 15;
pub const RETRO_DEVICE_ID_LIGHTGUN_TRIGGER: u32 = 2;
pub const RETRO_DEVICE_ID_LIGHTGUN_RELOAD: u32 = 16;
pub const RETRO_DEVICE_ID_LIGHTGUN_AUX_A: u32 = 3;
pub const RETRO_DEVICE_ID_LIGHTGUN_AUX_B: u32 = 4;
pub const RETRO_DEVICE_ID_LIGHTGUN_START: u32 = 6;
pub const RETRO_DEVICE_ID_LIGHTGUN_SELECT: u32 = 7;
pub const RETRO_DEVICE_ID_LIGHTGUN_AUX_C: u32 = 8;
pub const RETRO_DEVICE_ID_LIGHTGUN_DPAD_UP: u32 = 9;
pub const RETRO_DEVICE_ID_LIGHTGUN_DPAD_DOWN: u32 = 10;
pub const RETRO_DEVICE_ID_LIGHTGUN_DPAD_LEFT: u32 = 11;
pub const RETRO_DEVICE_ID_LIGHTGUN_DPAD_RIGHT: u32 = 12;
pub const RETRO_DEVICE_ID_LIGHTGUN_X: u32 = 0;
pub const RETRO_DEVICE_ID_LIGHTGUN_Y: u32 = 1;
pub const RETRO_DEVICE_ID_LIGHTGUN_CURSOR: u32 = 3;
pub const RETRO_DEVICE_ID_LIGHTGUN_TURBO: u32 = 4;
pub const RETRO_DEVICE_ID_LIGHTGUN_PAUSE: u32 = 5;
pub const RETRO_DEVICE_ID_POINTER_X: u32 = 0;
pub const RETRO_DEVICE_ID_POINTER_Y: u32 = 1;
pub const RETRO_DEVICE_ID_POINTER_PRESSED: u32 = 2;
pub const RETRO_DEVICE_ID_POINTER_COUNT: u32 = 3;
pub const RETRO_REGION_NTSC: u32 = 0;
pub const RETRO_REGION_PAL: u32 = 1;
pub const RETRO_MEMORY_MASK: u32 = 255;
pub const RETRO_MEMORY_SAVE_RAM: u32 = 0;
pub const RETRO_MEMORY_RTC: u32 = 1;
pub const RETRO_MEMORY_SYSTEM_RAM: u32 = 2;
pub const RETRO_MEMORY_VIDEO_RAM: u32 = 3;
pub const RETRO_ENVIRONMENT_EXPERIMENTAL: u32 = 65536;
pub const RETRO_ENVIRONMENT_PRIVATE: u32 = 131072;
pub const RETRO_ENVIRONMENT_SET_ROTATION: u32 = 1;
pub const RETRO_ENVIRONMENT_GET_OVERSCAN: u32 = 2;
pub const RETRO_ENVIRONMENT_GET_CAN_DUPE: u32 = 3;
pub const RETRO_ENVIRONMENT_SET_MESSAGE: u32 = 6;
pub const RETRO_ENVIRONMENT_SHUTDOWN: u32 = 7;
pub const RETRO_ENVIRONMENT_SET_PERFORMANCE_LEVEL: u32 = 8;
pub const RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY: u32 = 9;
pub const RETRO_ENVIRONMENT_SET_PIXEL_FORMAT: u32 = 10;
pub const RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS: u32 = 11;
pub const RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK: u32 = 12;
pub const RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE: u32 = 13;
pub const RETRO_ENVIRONMENT_SET_HW_RENDER: u32 = 14;
pub const RETRO_ENVIRONMENT_GET_VARIABLE: u32 = 15;
pub const RETRO_ENVIRONMENT_SET_VARIABLES: u32 = 16;
pub const RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE: u32 = 17;
pub const RETRO_ENVIRONMENT_SET_SUPPORT_NO_GAME: u32 = 18;
pub const RETRO_ENVIRONMENT_GET_LIBRETRO_PATH: u32 = 19;
pub const RETRO_ENVIRONMENT_SET_FRAME_TIME_CALLBACK: u32 = 21;
pub const RETRO_ENVIRONMENT_SET_AUDIO_CALLBACK: u32 = 22;
pub const RETRO_ENVIRONMENT_GET_RUMBLE_INTERFACE: u32 = 23;
pub const RETRO_ENVIRONMENT_GET_INPUT_DEVICE_CAPABILITIES: u32 = 24;
pub const RETRO_ENVIRONMENT_GET_SENSOR_INTERFACE: u32 = 65561;
pub const RETRO_ENVIRONMENT_GET_CAMERA_INTERFACE: u32 = 65562;
pub const RETRO_ENVIRONMENT_GET_LOG_INTERFACE: u32 = 27;
pub const RETRO_ENVIRONMENT_GET_PERF_INTERFACE: u32 = 28;
pub const RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE: u32 = 29;
pub const RETRO_ENVIRONMENT_GET_CONTENT_DIRECTORY: u32 = 30;
pub const RETRO_ENVIRONMENT_GET_CORE_ASSETS_DIRECTORY: u32 = 30;
pub const RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY: u32 = 31;
pub const RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO: u32 = 32;
pub const RETRO_ENVIRONMENT_SET_PROC_ADDRESS_CALLBACK: u32 = 33;
pub const RETRO_ENVIRONMENT_SET_SUBSYSTEM_INFO: u32 = 34;
pub const RETRO_ENVIRONMENT_SET_CONTROLLER_INFO: u32 = 35;
pub const RETRO_ENVIRONMENT_SET_MEMORY_MAPS: u32 = 65572;
pub const RETRO_ENVIRONMENT_SET_GEOMETRY: u32 = 37;
pub const RETRO_ENVIRONMENT_GET_USERNAME: u32 = 38;
pub const RETRO_ENVIRONMENT_GET_LANGUAGE: u32 = 39;
pub const RETRO_ENVIRONMENT_GET_CURRENT_SOFTWARE_FRAMEBUFFER: u32 = 65576;
pub const RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE: u32 = 65577;
pub const RETRO_ENVIRONMENT_SET_SUPPORT_ACHIEVEMENTS: u32 = 65578;
pub const RETRO_ENVIRONMENT_SET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE: u32 = 65579;
pub const RETRO_ENVIRONMENT_SET_SERIALIZATION_QUIRKS: u32 = 44;
pub const RETRO_ENVIRONMENT_SET_HW_SHARED_CONTEXT: u32 = 65580;
pub const RETRO_ENVIRONMENT_GET_VFS_INTERFACE: u32 = 65581;
pub const RETRO_ENVIRONMENT_GET_LED_INTERFACE: u32 = 65582;
pub const RETRO_ENVIRONMENT_GET_AUDIO_VIDEO_ENABLE: u32 = 65583;
pub const RETRO_ENVIRONMENT_GET_MIDI_INTERFACE: u32 = 65584;
pub const RETRO_ENVIRONMENT_GET_FASTFORWARDING: u32 = 65585;
pub const RETRO_ENVIRONMENT_GET_TARGET_REFRESH_RATE: u32 = 65586;
pub const RETRO_ENVIRONMENT_GET_INPUT_BITMASKS: u32 = 65587;
pub const RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION: u32 = 52;
pub const RETRO_ENVIRONMENT_SET_CORE_OPTIONS: u32 = 53;
pub const RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL: u32 = 54;
pub const RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY: u32 = 55;
pub const RETRO_ENVIRONMENT_GET_PREFERRED_HW_RENDER: u32 = 56;
pub const RETRO_ENVIRONMENT_GET_DISK_CONTROL_INTERFACE_VERSION: u32 = 57;
pub const RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE: u32 = 58;
pub const RETRO_ENVIRONMENT_GET_MESSAGE_INTERFACE_VERSION: u32 = 59;
pub const RETRO_ENVIRONMENT_SET_MESSAGE_EXT: u32 = 60;
pub const RETRO_ENVIRONMENT_GET_INPUT_MAX_USERS: u32 = 61;
pub const RETRO_ENVIRONMENT_SET_AUDIO_BUFFER_STATUS_CALLBACK: u32 = 62;
pub const RETRO_ENVIRONMENT_SET_MINIMUM_AUDIO_LATENCY: u32 = 63;
pub const RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE: u32 = 64;
pub const RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE: u32 = 65;
pub const RETRO_ENVIRONMENT_GET_GAME_INFO_EXT: u32 = 66;
pub const RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2: u32 = 67;
pub const RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL: u32 = 68;
pub const RETRO_ENVIRONMENT_SET_CORE_OPTIONS_UPDATE_DISPLAY_CALLBACK: u32 = 69;
pub const RETRO_ENVIRONMENT_SET_VARIABLE: u32 = 70;
pub const RETRO_ENVIRONMENT_GET_THROTTLE_STATE: u32 = 65607;
pub const RETRO_ENVIRONMENT_GET_SAVESTATE_CONTEXT: u32 = 65608;
pub const RETRO_ENVIRONMENT_GET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_SUPPORT: u32 = 65609;
pub const RETRO_ENVIRONMENT_GET_JIT_CAPABLE: u32 = 74;
pub const RETRO_ENVIRONMENT_GET_MICROPHONE_INTERFACE: u32 = 65611;
pub const RETRO_ENVIRONMENT_SET_NETPACKET_INTERFACE: u32 = 76;
pub const RETRO_ENVIRONMENT_GET_DEVICE_POWER: u32 = 65613;
pub const RETRO_VFS_FILE_ACCESS_READ: u32 = 1;
pub const RETRO_VFS_FILE_ACCESS_WRITE: u32 = 2;
pub const RETRO_VFS_FILE_ACCESS_READ_WRITE: u32 = 3;
pub const RETRO_VFS_FILE_ACCESS_UPDATE_EXISTING: u32 = 4;
pub const RETRO_VFS_FILE_ACCESS_HINT_NONE: u32 = 0;
pub const RETRO_VFS_FILE_ACCESS_HINT_FREQUENT_ACCESS: u32 = 1;
pub const RETRO_VFS_SEEK_POSITION_START: u32 = 0;
pub const RETRO_VFS_SEEK_POSITION_CURRENT: u32 = 1;
pub const RETRO_VFS_SEEK_POSITION_END: u32 = 2;
pub const RETRO_VFS_STAT_IS_VALID: u32 = 1;
pub const RETRO_VFS_STAT_IS_DIRECTORY: u32 = 2;
pub const RETRO_VFS_STAT_IS_CHARACTER_SPECIAL: u32 = 4;
pub const RETRO_SERIALIZATION_QUIRK_INCOMPLETE: u32 = 1;
pub const RETRO_SERIALIZATION_QUIRK_MUST_INITIALIZE: u32 = 2;
pub const RETRO_SERIALIZATION_QUIRK_CORE_VARIABLE_SIZE: u32 = 4;
pub const RETRO_SERIALIZATION_QUIRK_FRONT_VARIABLE_SIZE: u32 = 8;
pub const RETRO_SERIALIZATION_QUIRK_SINGLE_SESSION: u32 = 16;
pub const RETRO_SERIALIZATION_QUIRK_ENDIAN_DEPENDENT: u32 = 32;
pub const RETRO_SERIALIZATION_QUIRK_PLATFORM_DEPENDENT: u32 = 64;
pub const RETRO_MEMDESC_CONST: u32 = 1;
pub const RETRO_MEMDESC_BIGENDIAN: u32 = 2;
pub const RETRO_MEMDESC_SYSTEM_RAM: u32 = 4;
pub const RETRO_MEMDESC_SAVE_RAM: u32 = 8;
pub const RETRO_MEMDESC_VIDEO_RAM: u32 = 16;
pub const RETRO_MEMDESC_ALIGN_2: u32 = 65536;
pub const RETRO_MEMDESC_ALIGN_4: u32 = 131072;
pub const RETRO_MEMDESC_ALIGN_8: u32 = 196608;
pub const RETRO_MEMDESC_MINSIZE_2: u32 = 16777216;
pub const RETRO_MEMDESC_MINSIZE_4: u32 = 33554432;
pub const RETRO_MEMDESC_MINSIZE_8: u32 = 50331648;
pub const RETRO_SIMD_SSE: u32 = 1;
pub const RETRO_SIMD_SSE2: u32 = 2;
pub const RETRO_SIMD_VMX: u32 = 4;
pub const RETRO_SIMD_VMX128: u32 = 8;
pub const RETRO_SIMD_AVX: u32 = 16;
pub const RETRO_SIMD_NEON: u32 = 32;
pub const RETRO_SIMD_SSE3: u32 = 64;
pub const RETRO_SIMD_SSSE3: u32 = 128;
pub const RETRO_SIMD_MMX: u32 = 256;
pub const RETRO_SIMD_MMXEXT: u32 = 512;
pub const RETRO_SIMD_SSE4: u32 = 1024;
pub const RETRO_SIMD_SSE42: u32 = 2048;
pub const RETRO_SIMD_AVX2: u32 = 4096;
pub const RETRO_SIMD_VFPU: u32 = 8192;
pub const RETRO_SIMD_PS: u32 = 16384;
pub const RETRO_SIMD_AES: u32 = 32768;
pub const RETRO_SIMD_VFPV3: u32 = 65536;
pub const RETRO_SIMD_VFPV4: u32 = 131072;
pub const RETRO_SIMD_POPCNT: u32 = 262144;
pub const RETRO_SIMD_MOVBE: u32 = 524288;
pub const RETRO_SIMD_CMOV: u32 = 1048576;
pub const RETRO_SIMD_ASIMD: u32 = 2097152;
pub const RETRO_SENSOR_ACCELEROMETER_X: u32 = 0;
pub const RETRO_SENSOR_ACCELEROMETER_Y: u32 = 1;
pub const RETRO_SENSOR_ACCELEROMETER_Z: u32 = 2;
pub const RETRO_SENSOR_GYROSCOPE_X: u32 = 3;
pub const RETRO_SENSOR_GYROSCOPE_Y: u32 = 4;
pub const RETRO_SENSOR_GYROSCOPE_Z: u32 = 5;
pub const RETRO_SENSOR_ILLUMINANCE: u32 = 6;
pub const RETRO_NETPACKET_UNRELIABLE: u32 = 0;
pub const RETRO_NETPACKET_RELIABLE: u32 = 1;
pub const RETRO_NETPACKET_UNSEQUENCED: u32 = 2;
pub const RETRO_NUM_CORE_OPTION_VALUES_MAX: u32 = 128;
pub const RETRO_MEMORY_ACCESS_WRITE: u32 = 1;
pub const RETRO_MEMORY_ACCESS_READ: u32 = 2;
pub const RETRO_MEMORY_TYPE_CACHED: u32 = 1;
pub const RETRO_THROTTLE_NONE: u32 = 0;
pub const RETRO_THROTTLE_FRAME_STEPPING: u32 = 1;
pub const RETRO_THROTTLE_FAST_FORWARD: u32 = 2;
pub const RETRO_THROTTLE_SLOW_MOTION: u32 = 3;
pub const RETRO_THROTTLE_REWINDING: u32 = 4;
pub const RETRO_THROTTLE_VSYNC: u32 = 5;
pub const RETRO_THROTTLE_UNBLOCKED: u32 = 6;
pub const RETRO_MICROPHONE_INTERFACE_VERSION: u32 = 1;
pub const RETRO_POWERSTATE_NO_ESTIMATE: i32 = -1;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Id values for LANGUAGE"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_language {
    RETRO_LANGUAGE_ENGLISH = 0,
    RETRO_LANGUAGE_JAPANESE = 1,
    RETRO_LANGUAGE_FRENCH = 2,
    RETRO_LANGUAGE_SPANISH = 3,
    RETRO_LANGUAGE_GERMAN = 4,
    RETRO_LANGUAGE_ITALIAN = 5,
    RETRO_LANGUAGE_DUTCH = 6,
    RETRO_LANGUAGE_PORTUGUESE_BRAZIL = 7,
    RETRO_LANGUAGE_PORTUGUESE_PORTUGAL = 8,
    RETRO_LANGUAGE_RUSSIAN = 9,
    RETRO_LANGUAGE_KOREAN = 10,
    RETRO_LANGUAGE_CHINESE_TRADITIONAL = 11,
    RETRO_LANGUAGE_CHINESE_SIMPLIFIED = 12,
    RETRO_LANGUAGE_ESPERANTO = 13,
    RETRO_LANGUAGE_POLISH = 14,
    RETRO_LANGUAGE_VIETNAMESE = 15,
    RETRO_LANGUAGE_ARABIC = 16,
    RETRO_LANGUAGE_GREEK = 17,
    RETRO_LANGUAGE_TURKISH = 18,
    RETRO_LANGUAGE_SLOVAK = 19,
    RETRO_LANGUAGE_PERSIAN = 20,
    RETRO_LANGUAGE_HEBREW = 21,
    RETRO_LANGUAGE_ASTURIAN = 22,
    RETRO_LANGUAGE_FINNISH = 23,
    RETRO_LANGUAGE_INDONESIAN = 24,
    RETRO_LANGUAGE_SWEDISH = 25,
    RETRO_LANGUAGE_UKRAINIAN = 26,
    RETRO_LANGUAGE_CZECH = 27,
    RETRO_LANGUAGE_CATALAN_VALENCIA = 28,
    RETRO_LANGUAGE_CATALAN = 29,
    RETRO_LANGUAGE_BRITISH_ENGLISH = 30,
    RETRO_LANGUAGE_HUNGARIAN = 31,
    RETRO_LANGUAGE_BELARUSIAN = 32,
    RETRO_LANGUAGE_LAST = 33,
    #[doc = " Ensure sizeof(enum) == sizeof(int)"]
    RETRO_LANGUAGE_DUMMY = 2147483647,
}
impl retro_key {
    pub const RETROK_UNKNOWN: retro_key = retro_key(0);
}
impl retro_key {
    pub const RETROK_FIRST: retro_key = retro_key(0);
}
impl retro_key {
    pub const RETROK_BACKSPACE: retro_key = retro_key(8);
}
impl retro_key {
    pub const RETROK_TAB: retro_key = retro_key(9);
}
impl retro_key {
    pub const RETROK_CLEAR: retro_key = retro_key(12);
}
impl retro_key {
    pub const RETROK_RETURN: retro_key = retro_key(13);
}
impl retro_key {
    pub const RETROK_PAUSE: retro_key = retro_key(19);
}
impl retro_key {
    pub const RETROK_ESCAPE: retro_key = retro_key(27);
}
impl retro_key {
    pub const RETROK_SPACE: retro_key = retro_key(32);
}
impl retro_key {
    pub const RETROK_EXCLAIM: retro_key = retro_key(33);
}
impl retro_key {
    pub const RETROK_QUOTEDBL: retro_key = retro_key(34);
}
impl retro_key {
    pub const RETROK_HASH: retro_key = retro_key(35);
}
impl retro_key {
    pub const RETROK_DOLLAR: retro_key = retro_key(36);
}
impl retro_key {
    pub const RETROK_AMPERSAND: retro_key = retro_key(38);
}
impl retro_key {
    pub const RETROK_QUOTE: retro_key = retro_key(39);
}
impl retro_key {
    pub const RETROK_LEFTPAREN: retro_key = retro_key(40);
}
impl retro_key {
    pub const RETROK_RIGHTPAREN: retro_key = retro_key(41);
}
impl retro_key {
    pub const RETROK_ASTERISK: retro_key = retro_key(42);
}
impl retro_key {
    pub const RETROK_PLUS: retro_key = retro_key(43);
}
impl retro_key {
    pub const RETROK_COMMA: retro_key = retro_key(44);
}
impl retro_key {
    pub const RETROK_MINUS: retro_key = retro_key(45);
}
impl retro_key {
    pub const RETROK_PERIOD: retro_key = retro_key(46);
}
impl retro_key {
    pub const RETROK_SLASH: retro_key = retro_key(47);
}
impl retro_key {
    pub const RETROK_0: retro_key = retro_key(48);
}
impl retro_key {
    pub const RETROK_1: retro_key = retro_key(49);
}
impl retro_key {
    pub const RETROK_2: retro_key = retro_key(50);
}
impl retro_key {
    pub const RETROK_3: retro_key = retro_key(51);
}
impl retro_key {
    pub const RETROK_4: retro_key = retro_key(52);
}
impl retro_key {
    pub const RETROK_5: retro_key = retro_key(53);
}
impl retro_key {
    pub const RETROK_6: retro_key = retro_key(54);
}
impl retro_key {
    pub const RETROK_7: retro_key = retro_key(55);
}
impl retro_key {
    pub const RETROK_8: retro_key = retro_key(56);
}
impl retro_key {
    pub const RETROK_9: retro_key = retro_key(57);
}
impl retro_key {
    pub const RETROK_COLON: retro_key = retro_key(58);
}
impl retro_key {
    pub const RETROK_SEMICOLON: retro_key = retro_key(59);
}
impl retro_key {
    pub const RETROK_LESS: retro_key = retro_key(60);
}
impl retro_key {
    pub const RETROK_EQUALS: retro_key = retro_key(61);
}
impl retro_key {
    pub const RETROK_GREATER: retro_key = retro_key(62);
}
impl retro_key {
    pub const RETROK_QUESTION: retro_key = retro_key(63);
}
impl retro_key {
    pub const RETROK_AT: retro_key = retro_key(64);
}
impl retro_key {
    pub const RETROK_LEFTBRACKET: retro_key = retro_key(91);
}
impl retro_key {
    pub const RETROK_BACKSLASH: retro_key = retro_key(92);
}
impl retro_key {
    pub const RETROK_RIGHTBRACKET: retro_key = retro_key(93);
}
impl retro_key {
    pub const RETROK_CARET: retro_key = retro_key(94);
}
impl retro_key {
    pub const RETROK_UNDERSCORE: retro_key = retro_key(95);
}
impl retro_key {
    pub const RETROK_BACKQUOTE: retro_key = retro_key(96);
}
impl retro_key {
    pub const RETROK_a: retro_key = retro_key(97);
}
impl retro_key {
    pub const RETROK_b: retro_key = retro_key(98);
}
impl retro_key {
    pub const RETROK_c: retro_key = retro_key(99);
}
impl retro_key {
    pub const RETROK_d: retro_key = retro_key(100);
}
impl retro_key {
    pub const RETROK_e: retro_key = retro_key(101);
}
impl retro_key {
    pub const RETROK_f: retro_key = retro_key(102);
}
impl retro_key {
    pub const RETROK_g: retro_key = retro_key(103);
}
impl retro_key {
    pub const RETROK_h: retro_key = retro_key(104);
}
impl retro_key {
    pub const RETROK_i: retro_key = retro_key(105);
}
impl retro_key {
    pub const RETROK_j: retro_key = retro_key(106);
}
impl retro_key {
    pub const RETROK_k: retro_key = retro_key(107);
}
impl retro_key {
    pub const RETROK_l: retro_key = retro_key(108);
}
impl retro_key {
    pub const RETROK_m: retro_key = retro_key(109);
}
impl retro_key {
    pub const RETROK_n: retro_key = retro_key(110);
}
impl retro_key {
    pub const RETROK_o: retro_key = retro_key(111);
}
impl retro_key {
    pub const RETROK_p: retro_key = retro_key(112);
}
impl retro_key {
    pub const RETROK_q: retro_key = retro_key(113);
}
impl retro_key {
    pub const RETROK_r: retro_key = retro_key(114);
}
impl retro_key {
    pub const RETROK_s: retro_key = retro_key(115);
}
impl retro_key {
    pub const RETROK_t: retro_key = retro_key(116);
}
impl retro_key {
    pub const RETROK_u: retro_key = retro_key(117);
}
impl retro_key {
    pub const RETROK_v: retro_key = retro_key(118);
}
impl retro_key {
    pub const RETROK_w: retro_key = retro_key(119);
}
impl retro_key {
    pub const RETROK_x: retro_key = retro_key(120);
}
impl retro_key {
    pub const RETROK_y: retro_key = retro_key(121);
}
impl retro_key {
    pub const RETROK_z: retro_key = retro_key(122);
}
impl retro_key {
    pub const RETROK_LEFTBRACE: retro_key = retro_key(123);
}
impl retro_key {
    pub const RETROK_BAR: retro_key = retro_key(124);
}
impl retro_key {
    pub const RETROK_RIGHTBRACE: retro_key = retro_key(125);
}
impl retro_key {
    pub const RETROK_TILDE: retro_key = retro_key(126);
}
impl retro_key {
    pub const RETROK_DELETE: retro_key = retro_key(127);
}
impl retro_key {
    pub const RETROK_KP0: retro_key = retro_key(256);
}
impl retro_key {
    pub const RETROK_KP1: retro_key = retro_key(257);
}
impl retro_key {
    pub const RETROK_KP2: retro_key = retro_key(258);
}
impl retro_key {
    pub const RETROK_KP3: retro_key = retro_key(259);
}
impl retro_key {
    pub const RETROK_KP4: retro_key = retro_key(260);
}
impl retro_key {
    pub const RETROK_KP5: retro_key = retro_key(261);
}
impl retro_key {
    pub const RETROK_KP6: retro_key = retro_key(262);
}
impl retro_key {
    pub const RETROK_KP7: retro_key = retro_key(263);
}
impl retro_key {
    pub const RETROK_KP8: retro_key = retro_key(264);
}
impl retro_key {
    pub const RETROK_KP9: retro_key = retro_key(265);
}
impl retro_key {
    pub const RETROK_KP_PERIOD: retro_key = retro_key(266);
}
impl retro_key {
    pub const RETROK_KP_DIVIDE: retro_key = retro_key(267);
}
impl retro_key {
    pub const RETROK_KP_MULTIPLY: retro_key = retro_key(268);
}
impl retro_key {
    pub const RETROK_KP_MINUS: retro_key = retro_key(269);
}
impl retro_key {
    pub const RETROK_KP_PLUS: retro_key = retro_key(270);
}
impl retro_key {
    pub const RETROK_KP_ENTER: retro_key = retro_key(271);
}
impl retro_key {
    pub const RETROK_KP_EQUALS: retro_key = retro_key(272);
}
impl retro_key {
    pub const RETROK_UP: retro_key = retro_key(273);
}
impl retro_key {
    pub const RETROK_DOWN: retro_key = retro_key(274);
}
impl retro_key {
    pub const RETROK_RIGHT: retro_key = retro_key(275);
}
impl retro_key {
    pub const RETROK_LEFT: retro_key = retro_key(276);
}
impl retro_key {
    pub const RETROK_INSERT: retro_key = retro_key(277);
}
impl retro_key {
    pub const RETROK_HOME: retro_key = retro_key(278);
}
impl retro_key {
    pub const RETROK_END: retro_key = retro_key(279);
}
impl retro_key {
    pub const RETROK_PAGEUP: retro_key = retro_key(280);
}
impl retro_key {
    pub const RETROK_PAGEDOWN: retro_key = retro_key(281);
}
impl retro_key {
    pub const RETROK_F1: retro_key = retro_key(282);
}
impl retro_key {
    pub const RETROK_F2: retro_key = retro_key(283);
}
impl retro_key {
    pub const RETROK_F3: retro_key = retro_key(284);
}
impl retro_key {
    pub const RETROK_F4: retro_key = retro_key(285);
}
impl retro_key {
    pub const RETROK_F5: retro_key = retro_key(286);
}
impl retro_key {
    pub const RETROK_F6: retro_key = retro_key(287);
}
impl retro_key {
    pub const RETROK_F7: retro_key = retro_key(288);
}
impl retro_key {
    pub const RETROK_F8: retro_key = retro_key(289);
}
impl retro_key {
    pub const RETROK_F9: retro_key = retro_key(290);
}
impl retro_key {
    pub const RETROK_F10: retro_key = retro_key(291);
}
impl retro_key {
    pub const RETROK_F11: retro_key = retro_key(292);
}
impl retro_key {
    pub const RETROK_F12: retro_key = retro_key(293);
}
impl retro_key {
    pub const RETROK_F13: retro_key = retro_key(294);
}
impl retro_key {
    pub const RETROK_F14: retro_key = retro_key(295);
}
impl retro_key {
    pub const RETROK_F15: retro_key = retro_key(296);
}
impl retro_key {
    pub const RETROK_NUMLOCK: retro_key = retro_key(300);
}
impl retro_key {
    pub const RETROK_CAPSLOCK: retro_key = retro_key(301);
}
impl retro_key {
    pub const RETROK_SCROLLOCK: retro_key = retro_key(302);
}
impl retro_key {
    pub const RETROK_RSHIFT: retro_key = retro_key(303);
}
impl retro_key {
    pub const RETROK_LSHIFT: retro_key = retro_key(304);
}
impl retro_key {
    pub const RETROK_RCTRL: retro_key = retro_key(305);
}
impl retro_key {
    pub const RETROK_LCTRL: retro_key = retro_key(306);
}
impl retro_key {
    pub const RETROK_RALT: retro_key = retro_key(307);
}
impl retro_key {
    pub const RETROK_LALT: retro_key = retro_key(308);
}
impl retro_key {
    pub const RETROK_RMETA: retro_key = retro_key(309);
}
impl retro_key {
    pub const RETROK_LMETA: retro_key = retro_key(310);
}
impl retro_key {
    pub const RETROK_LSUPER: retro_key = retro_key(311);
}
impl retro_key {
    pub const RETROK_RSUPER: retro_key = retro_key(312);
}
impl retro_key {
    pub const RETROK_MODE: retro_key = retro_key(313);
}
impl retro_key {
    pub const RETROK_COMPOSE: retro_key = retro_key(314);
}
impl retro_key {
    pub const RETROK_HELP: retro_key = retro_key(315);
}
impl retro_key {
    pub const RETROK_PRINT: retro_key = retro_key(316);
}
impl retro_key {
    pub const RETROK_SYSREQ: retro_key = retro_key(317);
}
impl retro_key {
    pub const RETROK_BREAK: retro_key = retro_key(318);
}
impl retro_key {
    pub const RETROK_MENU: retro_key = retro_key(319);
}
impl retro_key {
    pub const RETROK_POWER: retro_key = retro_key(320);
}
impl retro_key {
    pub const RETROK_EURO: retro_key = retro_key(321);
}
impl retro_key {
    pub const RETROK_UNDO: retro_key = retro_key(322);
}
impl retro_key {
    pub const RETROK_OEM_102: retro_key = retro_key(323);
}
impl retro_key {
    pub const RETROK_LAST: retro_key = retro_key(324);
}
impl retro_key {
    #[doc = " Ensure sizeof(enum) == sizeof(int)"]
    pub const RETROK_DUMMY: retro_key = retro_key(2147483647);
}
#[repr(transparent)]
#[doc = " Keysyms used for ID in input state callback when polling RETRO_KEYBOARD."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct retro_key(pub ::std::os::raw::c_uint);
impl retro_mod {
    pub const RETROKMOD_NONE: retro_mod = retro_mod(0);
}
impl retro_mod {
    pub const RETROKMOD_SHIFT: retro_mod = retro_mod(1);
}
impl retro_mod {
    pub const RETROKMOD_CTRL: retro_mod = retro_mod(2);
}
impl retro_mod {
    pub const RETROKMOD_ALT: retro_mod = retro_mod(4);
}
impl retro_mod {
    pub const RETROKMOD_META: retro_mod = retro_mod(8);
}
impl retro_mod {
    pub const RETROKMOD_NUMLOCK: retro_mod = retro_mod(16);
}
impl retro_mod {
    pub const RETROKMOD_CAPSLOCK: retro_mod = retro_mod(32);
}
impl retro_mod {
    pub const RETROKMOD_SCROLLOCK: retro_mod = retro_mod(64);
}
impl retro_mod {
    #[doc = " Ensure sizeof(enum) == sizeof(int)"]
    pub const RETROKMOD_DUMMY: retro_mod = retro_mod(2147483647);
}
impl ::std::ops::BitOr<retro_mod> for retro_mod {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        retro_mod(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for retro_mod {
    #[inline]
    fn bitor_assign(&mut self, rhs: retro_mod) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<retro_mod> for retro_mod {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        retro_mod(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for retro_mod {
    #[inline]
    fn bitand_assign(&mut self, rhs: retro_mod) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct retro_mod(pub ::std::os::raw::c_uint);
#[doc = " Opaque file handle\n Introduced in VFS API v1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_vfs_file_handle {
    _unused: [u8; 0],
}
#[doc = " Opaque directory handle\n Introduced in VFS API v3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_vfs_dir_handle {
    _unused: [u8; 0],
}
#[doc = " Get path from opaque handle. Returns the exact same path passed to file_open when getting the handle\n Introduced in VFS API v1"]
pub type retro_vfs_get_path_t = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut retro_vfs_file_handle) -> *const ::std::os::raw::c_char,
>;
#[doc = " Open a file for reading or writing. If path points to a directory, this will\n fail. Returns the opaque file handle, or NULL for error.\n Introduced in VFS API v1"]
pub type retro_vfs_open_t = ::std::option::Option<
    unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_uint,
        hints: ::std::os::raw::c_uint,
    ) -> *mut retro_vfs_file_handle,
>;
#[doc = " Close the file and release its resources. Must be called if open_file returns non-NULL. Returns 0 on success, -1 on failure.\n Whether the call succeeds ot not, the handle passed as parameter becomes invalid and should no longer be used.\n Introduced in VFS API v1"]
pub type retro_vfs_close_t = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut retro_vfs_file_handle) -> ::std::os::raw::c_int,
>;
#[doc = " Return the size of the file in bytes, or -1 for error.\n Introduced in VFS API v1"]
pub type retro_vfs_size_t =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut retro_vfs_file_handle) -> i64>;
#[doc = " Truncate file to specified size. Returns 0 on success or -1 on error\n Introduced in VFS API v2"]
pub type retro_vfs_truncate_t = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut retro_vfs_file_handle, length: i64) -> i64,
>;
#[doc = " Get the current read / write position for the file. Returns -1 for error.\n Introduced in VFS API v1"]
pub type retro_vfs_tell_t =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut retro_vfs_file_handle) -> i64>;
#[doc = " Set the current read/write position for the file. Returns the new position, -1 for error.\n Introduced in VFS API v1"]
pub type retro_vfs_seek_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut retro_vfs_file_handle,
        offset: i64,
        seek_position: ::std::os::raw::c_int,
    ) -> i64,
>;
#[doc = " Read data from a file. Returns the number of bytes read, or -1 for error.\n Introduced in VFS API v1"]
pub type retro_vfs_read_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut retro_vfs_file_handle,
        s: *mut ::std::os::raw::c_void,
        len: u64,
    ) -> i64,
>;
#[doc = " Write data to a file. Returns the number of bytes written, or -1 for error.\n Introduced in VFS API v1"]
pub type retro_vfs_write_t = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut retro_vfs_file_handle,
        s: *const ::std::os::raw::c_void,
        len: u64,
    ) -> i64,
>;
#[doc = " Flush pending writes to file, if using buffered IO. Returns 0 on sucess, or -1 on failure.\n Introduced in VFS API v1"]
pub type retro_vfs_flush_t = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut retro_vfs_file_handle) -> ::std::os::raw::c_int,
>;
#[doc = " Delete the specified file. Returns 0 on success, -1 on failure\n Introduced in VFS API v1"]
pub type retro_vfs_remove_t = ::std::option::Option<
    unsafe extern "C" fn(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
#[doc = " Rename the specified file. Returns 0 on success, -1 on failure\n Introduced in VFS API v1"]
pub type retro_vfs_rename_t = ::std::option::Option<
    unsafe extern "C" fn(
        old_path: *const ::std::os::raw::c_char,
        new_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Stat the specified file. Retruns a bitmask of RETRO_VFS_STAT_* flags, none are set if path was not valid.\n Additionally stores file size in given variable, unless NULL is given.\n Introduced in VFS API v3"]
pub type retro_vfs_stat_t = ::std::option::Option<
    unsafe extern "C" fn(
        path: *const ::std::os::raw::c_char,
        size: *mut i32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Create the specified directory. Returns 0 on success, -1 on unknown failure, -2 if already exists.\n Introduced in VFS API v3"]
pub type retro_vfs_mkdir_t = ::std::option::Option<
    unsafe extern "C" fn(dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
#[doc = " Open the specified directory for listing. Returns the opaque dir handle, or NULL for error.\n Support for the include_hidden argument may vary depending on the platform.\n Introduced in VFS API v3"]
pub type retro_vfs_opendir_t = ::std::option::Option<
    unsafe extern "C" fn(
        dir: *const ::std::os::raw::c_char,
        include_hidden: bool,
    ) -> *mut retro_vfs_dir_handle,
>;
#[doc = " Read the directory entry at the current position, and move the read pointer to the next position.\n Returns true on success, false if already on the last entry.\n Introduced in VFS API v3"]
pub type retro_vfs_readdir_t =
    ::std::option::Option<unsafe extern "C" fn(dirstream: *mut retro_vfs_dir_handle) -> bool>;
#[doc = " Get the name of the last entry read. Returns a string on success, or NULL for error.\n The returned string pointer is valid until the next call to readdir or closedir.\n Introduced in VFS API v3"]
pub type retro_vfs_dirent_get_name_t = ::std::option::Option<
    unsafe extern "C" fn(dirstream: *mut retro_vfs_dir_handle) -> *const ::std::os::raw::c_char,
>;
#[doc = " Check if the last entry read was a directory. Returns true if it was, false otherwise (or on error).\n Introduced in VFS API v3"]
pub type retro_vfs_dirent_is_dir_t =
    ::std::option::Option<unsafe extern "C" fn(dirstream: *mut retro_vfs_dir_handle) -> bool>;
#[doc = " Close the directory and release its resources. Must be called if opendir returns non-NULL. Returns 0 on success, -1 on failure.\n Whether the call succeeds ot not, the handle passed as parameter becomes invalid and should no longer be used.\n Introduced in VFS API v3"]
pub type retro_vfs_closedir_t = ::std::option::Option<
    unsafe extern "C" fn(dirstream: *mut retro_vfs_dir_handle) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_vfs_interface {
    #[doc = " VFS API v1"]
    pub get_path: retro_vfs_get_path_t,
    pub open: retro_vfs_open_t,
    pub close: retro_vfs_close_t,
    pub size: retro_vfs_size_t,
    pub tell: retro_vfs_tell_t,
    pub seek: retro_vfs_seek_t,
    pub read: retro_vfs_read_t,
    pub write: retro_vfs_write_t,
    pub flush: retro_vfs_flush_t,
    pub remove: retro_vfs_remove_t,
    pub rename: retro_vfs_rename_t,
    #[doc = " VFS API v2"]
    pub truncate: retro_vfs_truncate_t,
    #[doc = " VFS API v3"]
    pub stat: retro_vfs_stat_t,
    pub mkdir: retro_vfs_mkdir_t,
    pub opendir: retro_vfs_opendir_t,
    pub readdir: retro_vfs_readdir_t,
    pub dirent_get_name: retro_vfs_dirent_get_name_t,
    pub dirent_is_dir: retro_vfs_dirent_is_dir_t,
    pub closedir: retro_vfs_closedir_t,
}
#[test]
fn bindgen_test_layout_retro_vfs_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_vfs_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_vfs_interface>(),
        152usize,
        concat!("Size of: ", stringify!(retro_vfs_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_vfs_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_vfs_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(get_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rename) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mkdir) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opendir) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(opendir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readdir) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(readdir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirent_get_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(dirent_get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirent_is_dir) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(dirent_is_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closedir) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface),
            "::",
            stringify!(closedir)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_vfs_interface_info {
    #[doc = " Set by core: should this be higher than the version the front end supports,\n front end will return false in the RETRO_ENVIRONMENT_GET_VFS_INTERFACE call\n Introduced in VFS API v1"]
    pub required_interface_version: u32,
    #[doc = " Frontend writes interface pointer here. The frontend also sets the actual\n version, must be at least required_interface_version.\n Introduced in VFS API v1"]
    pub iface: *mut retro_vfs_interface,
}
#[test]
fn bindgen_test_layout_retro_vfs_interface_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_vfs_interface_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_vfs_interface_info>(),
        16usize,
        concat!("Size of: ", stringify!(retro_vfs_interface_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_vfs_interface_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_vfs_interface_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required_interface_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface_info),
            "::",
            stringify!(required_interface_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_vfs_interface_info),
            "::",
            stringify!(iface)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_hw_render_interface_type {
    RETRO_HW_RENDER_INTERFACE_VULKAN = 0,
    RETRO_HW_RENDER_INTERFACE_D3D9 = 1,
    RETRO_HW_RENDER_INTERFACE_D3D10 = 2,
    RETRO_HW_RENDER_INTERFACE_D3D11 = 3,
    RETRO_HW_RENDER_INTERFACE_D3D12 = 4,
    RETRO_HW_RENDER_INTERFACE_GSKIT_PS2 = 5,
    RETRO_HW_RENDER_INTERFACE_DUMMY = 2147483647,
}
#[doc = " Base struct. All retro_hw_render_interface_* types\n contain at least these fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_hw_render_interface {
    pub interface_type: retro_hw_render_interface_type,
    pub interface_version: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_hw_render_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_hw_render_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_hw_render_interface>(),
        8usize,
        concat!("Size of: ", stringify!(retro_hw_render_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_hw_render_interface>(),
        4usize,
        concat!("Alignment of ", stringify!(retro_hw_render_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_interface),
            "::",
            stringify!(interface_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_interface),
            "::",
            stringify!(interface_version)
        )
    );
}
pub type retro_set_led_state_t = ::std::option::Option<
    unsafe extern "C" fn(led: ::std::os::raw::c_int, state: ::std::os::raw::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_led_interface {
    pub set_led_state: retro_set_led_state_t,
}
#[test]
fn bindgen_test_layout_retro_led_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_led_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_led_interface>(),
        8usize,
        concat!("Size of: ", stringify!(retro_led_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_led_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_led_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_led_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_led_interface),
            "::",
            stringify!(set_led_state)
        )
    );
}
#[doc = " Retrieves the current state of the MIDI input.\n Returns true if it's enabled, false otherwise."]
pub type retro_midi_input_enabled_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[doc = " Retrieves the current state of the MIDI output.\n Returns true if it's enabled, false otherwise"]
pub type retro_midi_output_enabled_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[doc = " Reads next byte from the input stream.\n Returns true if byte is read, false otherwise."]
pub type retro_midi_read_t = ::std::option::Option<unsafe extern "C" fn(byte: *mut u8) -> bool>;
#[doc = " Writes byte to the output stream.\n 'delta_time' is in microseconds and represent time elapsed since previous write.\n Returns true if byte is written, false otherwise."]
pub type retro_midi_write_t =
    ::std::option::Option<unsafe extern "C" fn(byte: u8, delta_time: u32) -> bool>;
#[doc = " Flushes previously written data.\n Returns true if successful, false otherwise."]
pub type retro_midi_flush_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_midi_interface {
    pub input_enabled: retro_midi_input_enabled_t,
    pub output_enabled: retro_midi_output_enabled_t,
    pub read: retro_midi_read_t,
    pub write: retro_midi_write_t,
    pub flush: retro_midi_flush_t,
}
#[test]
fn bindgen_test_layout_retro_midi_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_midi_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_midi_interface>(),
        40usize,
        concat!("Size of: ", stringify!(retro_midi_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_midi_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_midi_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_midi_interface),
            "::",
            stringify!(input_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_enabled) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_midi_interface),
            "::",
            stringify!(output_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_midi_interface),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_midi_interface),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_midi_interface),
            "::",
            stringify!(flush)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_hw_render_context_negotiation_interface_type {
    RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN = 0,
    RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_DUMMY = 2147483647,
}
#[doc = " Base struct. All retro_hw_render_context_negotiation_interface_* types\n contain at least these fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_hw_render_context_negotiation_interface {
    pub interface_type: retro_hw_render_context_negotiation_interface_type,
    pub interface_version: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_hw_render_context_negotiation_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_hw_render_context_negotiation_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_hw_render_context_negotiation_interface>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(retro_hw_render_context_negotiation_interface)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<retro_hw_render_context_negotiation_interface>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(retro_hw_render_context_negotiation_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_context_negotiation_interface),
            "::",
            stringify!(interface_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_context_negotiation_interface),
            "::",
            stringify!(interface_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_memory_descriptor {
    pub flags: u64,
    #[doc = " Pointer to the start of the relevant ROM or RAM chip.\n It's strongly recommended to use 'offset' if possible, rather than\n doing math on the pointer.\n\n If the same byte is mapped my multiple descriptors, their descriptors\n must have the same pointer.\n If 'start' does not point to the first byte in the pointer, put the\n difference in 'offset' instead.\n\n May be NULL if there's nothing usable here (e.g. hardware registers and\n open bus). No flags should be set if the pointer is NULL.\n It's recommended to minimize the number of descriptors if possible,\n but not mandatory."]
    pub ptr: *mut ::std::os::raw::c_void,
    pub offset: usize,
    #[doc = " This is the location in the emulated address space\n where the mapping starts."]
    pub start: usize,
    #[doc = " Which bits must be same as in 'start' for this mapping to apply.\n The first memory descriptor to claim a certain byte is the one\n that applies.\n A bit which is set in 'start' must also be set in this.\n Can be zero, in which case each byte is assumed mapped exactly once.\n In this case, 'len' must be a power of two."]
    pub select: usize,
    #[doc = " If this is nonzero, the set bits are assumed not connected to the\n memory chip's address pins."]
    pub disconnect: usize,
    #[doc = " This one tells the size of the current memory area.\n If, after start+disconnect are applied, the address is higher than\n this, the highest bit of the address is cleared.\n\n If the address is still too high, the next highest bit is cleared.\n Can be zero, in which case it's assumed to be infinite (as limited\n by 'select' and 'disconnect')."]
    pub len: usize,
    #[doc = " The address space name must consist of only a-zA-Z0-9_-,\n should be as short as feasible (maximum length is 8 plus the NUL),\n and may not be any other address space plus one or more 0-9A-F\n at the end.\n However, multiple memory descriptors for the same address space is\n allowed, and the address space name can be empty. NULL is treated\n as empty.\n\n Address space names are case sensitive, but avoid lowercase if possible.\n The same pointer may exist in multiple address spaces.\n\n Examples:\n blank+blank - valid (multiple things may be mapped in the same namespace)\n 'Sp'+'Sp' - valid (multiple things may be mapped in the same namespace)\n 'A'+'B' - valid (neither is a prefix of each other)\n 'S'+blank - valid ('S' is not in 0-9A-F)\n 'a'+blank - valid ('a' is not in 0-9A-F)\n 'a'+'A' - valid (neither is a prefix of each other)\n 'AR'+blank - valid ('R' is not in 0-9A-F)\n 'ARB'+blank - valid (the B can't be part of the address either, because\n                      there is no namespace 'AR')\n blank+'B' - not valid, because it's ambigous which address space B1234\n             would refer to.\n The length can't be used for that purpose; the frontend may want\n to append arbitrary data to an address, without a separator."]
    pub addrspace: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_memory_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<retro_memory_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_memory_descriptor>(),
        64usize,
        concat!("Size of: ", stringify!(retro_memory_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_memory_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_memory_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).select) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(select)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnect) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addrspace) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_descriptor),
            "::",
            stringify!(addrspace)
        )
    );
}
#[doc = " The frontend may use the largest value of 'start'+'select' in a\n certain namespace to infer the size of the address space.\n\n If the address space is larger than that, a mapping with .ptr=NULL\n should be at the end of the array, with .select set to all ones for\n as long as the address space is big.\n\n Sample descriptors (minus .ptr, and RETRO_MEMFLAG_ on the flags):\n SNES WRAM:\n .start=0x7E0000, .len=0x20000\n (Note that this must be mapped before the ROM in most cases; some of the\n ROM mappers\n try to claim $7E0000, or at least $7E8000.)\n SNES SPC700 RAM:\n .addrspace=\"S\", .len=0x10000\n SNES WRAM mirrors:\n .flags=MIRROR, .start=0x000000, .select=0xC0E000, .len=0x2000\n .flags=MIRROR, .start=0x800000, .select=0xC0E000, .len=0x2000\n SNES WRAM mirrors, alternate equivalent descriptor:\n .flags=MIRROR, .select=0x40E000, .disconnect=~0x1FFF\n (Various similar constructions can be created by combining parts of\n the above two.)\n SNES LoROM (512KB, mirrored a couple of times):\n .flags=CONST, .start=0x008000, .select=0x408000, .disconnect=0x8000, .len=512*1024\n .flags=CONST, .start=0x400000, .select=0x400000, .disconnect=0x8000, .len=512*1024\n SNES HiROM (4MB):\n .flags=CONST,                 .start=0x400000, .select=0x400000, .len=4*1024*1024\n .flags=CONST, .offset=0x8000, .start=0x008000, .select=0x408000, .len=4*1024*1024\n SNES ExHiROM (8MB):\n .flags=CONST, .offset=0,                  .start=0xC00000, .select=0xC00000, .len=4*1024*1024\n .flags=CONST, .offset=4*1024*1024,        .start=0x400000, .select=0xC00000, .len=4*1024*1024\n .flags=CONST, .offset=0x8000,             .start=0x808000, .select=0xC08000, .len=4*1024*1024\n .flags=CONST, .offset=4*1024*1024+0x8000, .start=0x008000, .select=0xC08000, .len=4*1024*1024\n Clarify the size of the address space:\n .ptr=NULL, .select=0xFFFFFF\n .len can be implied by .select in many of them, but was included for clarity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_memory_map {
    pub descriptors: *const retro_memory_descriptor,
    pub num_descriptors: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_memory_map() {
    const UNINIT: ::std::mem::MaybeUninit<retro_memory_map> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_memory_map>(),
        16usize,
        concat!("Size of: ", stringify!(retro_memory_map))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_memory_map>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_memory_map))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_map),
            "::",
            stringify!(descriptors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_descriptors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_memory_map),
            "::",
            stringify!(num_descriptors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_controller_description {
    #[doc = " Human-readable description of the controller. Even if using a generic\n input device type, this can be set to the particular device type the\n core uses."]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " Device type passed to retro_set_controller_port_device(). If the device\n type is a sub-class of a generic input device type, use the\n RETRO_DEVICE_SUBCLASS macro to create an ID.\n\n E.g. RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_JOYPAD, 1)."]
    pub id: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_controller_description() {
    const UNINIT: ::std::mem::MaybeUninit<retro_controller_description> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_controller_description>(),
        16usize,
        concat!("Size of: ", stringify!(retro_controller_description))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_controller_description>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_controller_description))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_controller_description),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_controller_description),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_controller_info {
    pub types: *const retro_controller_description,
    pub num_types: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_controller_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_controller_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_controller_info>(),
        16usize,
        concat!("Size of: ", stringify!(retro_controller_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_controller_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_controller_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_controller_info),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_types) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_controller_info),
            "::",
            stringify!(num_types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_subsystem_memory_info {
    #[doc = " The extension associated with a memory type, e.g. \"psram\"."]
    pub extension: *const ::std::os::raw::c_char,
    #[doc = " The memory type for retro_get_memory(). This should be at\n least 0x100 to avoid conflict with standardized\n libretro memory types."]
    pub type_: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_subsystem_memory_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_subsystem_memory_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_subsystem_memory_info>(),
        16usize,
        concat!("Size of: ", stringify!(retro_subsystem_memory_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_subsystem_memory_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_subsystem_memory_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_memory_info),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_memory_info),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_subsystem_rom_info {
    #[doc = " Describes what the content is (SGB BIOS, GB ROM, etc)."]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " Same definition as retro_get_system_info()."]
    pub valid_extensions: *const ::std::os::raw::c_char,
    #[doc = " Same definition as retro_get_system_info()."]
    pub need_fullpath: bool,
    #[doc = " Same definition as retro_get_system_info()."]
    pub block_extract: bool,
    #[doc = " This is set if the content is required to load a game.\n If this is set to false, a zeroed-out retro_game_info can be passed."]
    pub required: bool,
    #[doc = " Content can have multiple associated persistent\n memory types (retro_get_memory())."]
    pub memory: *const retro_subsystem_memory_info,
    pub num_memory: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_subsystem_rom_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_subsystem_rom_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_subsystem_rom_info>(),
        40usize,
        concat!("Size of: ", stringify!(retro_subsystem_rom_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_subsystem_rom_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_subsystem_rom_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_rom_info),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid_extensions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_rom_info),
            "::",
            stringify!(valid_extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).need_fullpath) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_rom_info),
            "::",
            stringify!(need_fullpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_extract) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_rom_info),
            "::",
            stringify!(block_extract)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_rom_info),
            "::",
            stringify!(required)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_rom_info),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_memory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_rom_info),
            "::",
            stringify!(num_memory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_subsystem_info {
    #[doc = " Human-readable string of the subsystem type, e.g. \"Super GameBoy\""]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " A computer friendly short string identifier for the subsystem type.\n This name must be [a-z].\n E.g. if desc is \"Super GameBoy\", this can be \"sgb\".\n This identifier can be used for command-line interfaces, etc."]
    pub ident: *const ::std::os::raw::c_char,
    #[doc = " Infos for each content file. The first entry is assumed to be the\n \"most significant\" content for frontend purposes.\n E.g. with Super GameBoy, the first content should be the GameBoy ROM,\n as it is the most \"significant\" content to a user.\n If a frontend creates new file paths based on the content used\n (e.g. savestates), it should use the path for the first ROM to do so."]
    pub roms: *const retro_subsystem_rom_info,
    #[doc = " Number of content files associated with a subsystem."]
    pub num_roms: ::std::os::raw::c_uint,
    #[doc = " The type passed to retro_load_game_special()."]
    pub id: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_subsystem_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_subsystem_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_subsystem_info>(),
        32usize,
        concat!("Size of: ", stringify!(retro_subsystem_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_subsystem_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_subsystem_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_info),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_info),
            "::",
            stringify!(ident)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roms) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_info),
            "::",
            stringify!(roms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_roms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_info),
            "::",
            stringify!(num_roms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_subsystem_info),
            "::",
            stringify!(id)
        )
    );
}
pub type retro_proc_address_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " libretro API extension functions:\n (None here so far).\n\n Get a symbol from a libretro core.\n Cores should only return symbols which are actual\n extensions to the libretro API.\n\n Frontends should not use this to obtain symbols to standard\n libretro entry points (static linking or dlsym).\n\n The symbol name must be equal to the function name,\n e.g. if void retro_foo(void); exists, the symbol must be called \"retro_foo\".\n The returned function pointer must be cast to the corresponding type."]
pub type retro_get_proc_address_t = ::std::option::Option<
    unsafe extern "C" fn(sym: *const ::std::os::raw::c_char) -> retro_proc_address_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_get_proc_address_interface {
    pub get_proc_address: retro_get_proc_address_t,
}
#[test]
fn bindgen_test_layout_retro_get_proc_address_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_get_proc_address_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_get_proc_address_interface>(),
        8usize,
        concat!("Size of: ", stringify!(retro_get_proc_address_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_get_proc_address_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(retro_get_proc_address_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_proc_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_get_proc_address_interface),
            "::",
            stringify!(get_proc_address)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_log_level {
    RETRO_LOG_DEBUG = 0,
    RETRO_LOG_INFO = 1,
    RETRO_LOG_WARN = 2,
    RETRO_LOG_ERROR = 3,
    RETRO_LOG_DUMMY = 2147483647,
}
#[doc = " Logging function. Takes log level argument as well."]
pub type retro_log_printf_t = ::std::option::Option<
    unsafe extern "C" fn(level: retro_log_level, fmt: *const ::std::os::raw::c_char, ...),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_log_callback {
    pub log: retro_log_printf_t,
}
#[test]
fn bindgen_test_layout_retro_log_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_log_callback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_log_callback>(),
        8usize,
        concat!("Size of: ", stringify!(retro_log_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_log_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_log_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_log_callback),
            "::",
            stringify!(log)
        )
    );
}
pub type retro_perf_tick_t = u64;
pub type retro_time_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_perf_counter {
    pub ident: *const ::std::os::raw::c_char,
    pub start: retro_perf_tick_t,
    pub total: retro_perf_tick_t,
    pub call_cnt: retro_perf_tick_t,
    pub registered: bool,
}
#[test]
fn bindgen_test_layout_retro_perf_counter() {
    const UNINIT: ::std::mem::MaybeUninit<retro_perf_counter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_perf_counter>(),
        40usize,
        concat!("Size of: ", stringify!(retro_perf_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_perf_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_perf_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_counter),
            "::",
            stringify!(ident)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_counter),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_counter),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).call_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_counter),
            "::",
            stringify!(call_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registered) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_counter),
            "::",
            stringify!(registered)
        )
    );
}
#[doc = " Returns current time in microseconds.\n Tries to use the most accurate timer available."]
pub type retro_perf_get_time_usec_t = ::std::option::Option<unsafe extern "C" fn() -> retro_time_t>;
#[doc = " A simple counter. Usually nanoseconds, but can also be CPU cycles.\n Can be used directly if desired (when creating a more sophisticated\n performance counter system)."]
pub type retro_perf_get_counter_t =
    ::std::option::Option<unsafe extern "C" fn() -> retro_perf_tick_t>;
#[doc = " Returns a bit-mask of detected CPU features (RETRO_SIMD_*)."]
pub type retro_get_cpu_features_t = ::std::option::Option<unsafe extern "C" fn() -> u64>;
#[doc = " Asks frontend to log and/or display the state of performance counters.\n Performance counters can always be poked into manually as well."]
pub type retro_perf_log_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Register a performance counter.\n ident field must be set with a discrete value and other values in\n retro_perf_counter must be 0.\n Registering can be called multiple times. To avoid calling to\n frontend redundantly, you can check registered field first."]
pub type retro_perf_register_t =
    ::std::option::Option<unsafe extern "C" fn(counter: *mut retro_perf_counter)>;
#[doc = " Starts a registered counter."]
pub type retro_perf_start_t =
    ::std::option::Option<unsafe extern "C" fn(counter: *mut retro_perf_counter)>;
#[doc = " Stops a registered counter."]
pub type retro_perf_stop_t =
    ::std::option::Option<unsafe extern "C" fn(counter: *mut retro_perf_counter)>;
#[doc = " For convenience it can be useful to wrap register, start and stop in macros.\n E.g.:\n #ifdef LOG_PERFORMANCE\n #define RETRO_PERFORMANCE_INIT(perf_cb, name) static struct retro_perf_counter name = {#name}; if (!name.registered) perf_cb.perf_register(&(name))\n #define RETRO_PERFORMANCE_START(perf_cb, name) perf_cb.perf_start(&(name))\n #define RETRO_PERFORMANCE_STOP(perf_cb, name) perf_cb.perf_stop(&(name))\n #else\n ... Blank macros ...\n #endif\n\n These can then be used mid-functions around code snippets.\n\n extern struct retro_perf_callback perf_cb;  * Somewhere in the core.\n\n void do_some_heavy_work(void)\n {\n    RETRO_PERFORMANCE_INIT(cb, work_1;\n    RETRO_PERFORMANCE_START(cb, work_1);\n    heavy_work_1();\n    RETRO_PERFORMANCE_STOP(cb, work_1);\n\n    RETRO_PERFORMANCE_INIT(cb, work_2);\n    RETRO_PERFORMANCE_START(cb, work_2);\n    heavy_work_2();\n    RETRO_PERFORMANCE_STOP(cb, work_2);\n }\n\n void retro_deinit(void)\n {\n    perf_cb.perf_log();  * Log all perf counters here for example.\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_perf_callback {
    pub get_time_usec: retro_perf_get_time_usec_t,
    pub get_cpu_features: retro_get_cpu_features_t,
    pub get_perf_counter: retro_perf_get_counter_t,
    pub perf_register: retro_perf_register_t,
    pub perf_start: retro_perf_start_t,
    pub perf_stop: retro_perf_stop_t,
    pub perf_log: retro_perf_log_t,
}
#[test]
fn bindgen_test_layout_retro_perf_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_perf_callback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_perf_callback>(),
        56usize,
        concat!("Size of: ", stringify!(retro_perf_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_perf_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_perf_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_time_usec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_callback),
            "::",
            stringify!(get_time_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_cpu_features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_callback),
            "::",
            stringify!(get_cpu_features)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_perf_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_callback),
            "::",
            stringify!(get_perf_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perf_register) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_callback),
            "::",
            stringify!(perf_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perf_start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_callback),
            "::",
            stringify!(perf_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perf_stop) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_callback),
            "::",
            stringify!(perf_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).perf_log) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_perf_callback),
            "::",
            stringify!(perf_log)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " FIXME: Document the sensor API and work out behavior.\n It will be marked as experimental until then."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_sensor_action {
    RETRO_SENSOR_ACCELEROMETER_ENABLE = 0,
    RETRO_SENSOR_ACCELEROMETER_DISABLE = 1,
    RETRO_SENSOR_GYROSCOPE_ENABLE = 2,
    RETRO_SENSOR_GYROSCOPE_DISABLE = 3,
    RETRO_SENSOR_ILLUMINANCE_ENABLE = 4,
    RETRO_SENSOR_ILLUMINANCE_DISABLE = 5,
    RETRO_SENSOR_DUMMY = 2147483647,
}
pub type retro_set_sensor_state_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: ::std::os::raw::c_uint,
        action: retro_sensor_action,
        rate: ::std::os::raw::c_uint,
    ) -> bool,
>;
pub type retro_sensor_get_input_t = ::std::option::Option<
    unsafe extern "C" fn(port: ::std::os::raw::c_uint, id: ::std::os::raw::c_uint) -> f32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_sensor_interface {
    pub set_sensor_state: retro_set_sensor_state_t,
    pub get_sensor_input: retro_sensor_get_input_t,
}
#[test]
fn bindgen_test_layout_retro_sensor_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_sensor_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_sensor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(retro_sensor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_sensor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_sensor_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_sensor_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_sensor_interface),
            "::",
            stringify!(set_sensor_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sensor_input) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_sensor_interface),
            "::",
            stringify!(get_sensor_input)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_camera_buffer {
    RETRO_CAMERA_BUFFER_OPENGL_TEXTURE = 0,
    RETRO_CAMERA_BUFFER_RAW_FRAMEBUFFER = 1,
    RETRO_CAMERA_BUFFER_DUMMY = 2147483647,
}
#[doc = " Starts the camera driver. Can only be called in retro_run()."]
pub type retro_camera_start_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[doc = " Stops the camera driver. Can only be called in retro_run()."]
pub type retro_camera_stop_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Callback which signals when the camera driver is initialized\n and/or deinitialized.\n retro_camera_start_t can be called in initialized callback."]
pub type retro_camera_lifetime_status_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " A callback for raw framebuffer data. buffer points to an XRGB8888 buffer.\n Width, height and pitch are similar to retro_video_refresh_t.\n First pixel is top-left origin."]
pub type retro_camera_frame_raw_framebuffer_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *const u32,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        pitch: usize,
    ),
>;
#[doc = " A callback for when OpenGL textures are used.\n\n texture_id is a texture owned by camera driver.\n Its state or content should be considered immutable, except for things like\n texture filtering and clamping.\n\n texture_target is the texture target for the GL texture.\n These can include e.g. GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, and possibly\n more depending on extensions.\n\n affine points to a packed 3x3 column-major matrix used to apply an affine\n transform to texture coordinates. (affine_matrix * vec3(coord_x, coord_y, 1.0))\n After transform, normalized texture coord (0, 0) should be bottom-left\n and (1, 1) should be top-right (or (width, height) for RECTANGLE).\n\n GL-specific typedefs are avoided here to avoid relying on gl.h in\n the API definition."]
pub type retro_camera_frame_opengl_texture_t = ::std::option::Option<
    unsafe extern "C" fn(
        texture_id: ::std::os::raw::c_uint,
        texture_target: ::std::os::raw::c_uint,
        affine: *const f32,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_camera_callback {
    #[doc = " Set by libretro core.\n Example bitmask: caps = (1 << RETRO_CAMERA_BUFFER_OPENGL_TEXTURE) | (1 << RETRO_CAMERA_BUFFER_RAW_FRAMEBUFFER)."]
    pub caps: u64,
    #[doc = " Desired resolution for camera. Is only used as a hint."]
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    #[doc = " Set by frontend."]
    pub start: retro_camera_start_t,
    pub stop: retro_camera_stop_t,
    #[doc = " Set by libretro core if raw framebuffer callbacks will be used."]
    pub frame_raw_framebuffer: retro_camera_frame_raw_framebuffer_t,
    #[doc = " Set by libretro core if OpenGL texture callbacks will be used."]
    pub frame_opengl_texture: retro_camera_frame_opengl_texture_t,
    #[doc = " Set by libretro core. Called after camera driver is initialized and\n ready to be started.\n Can be NULL, in which this callback is not called."]
    pub initialized: retro_camera_lifetime_status_t,
    #[doc = " Set by libretro core. Called right before camera driver is\n deinitialized.\n Can be NULL, in which this callback is not called."]
    pub deinitialized: retro_camera_lifetime_status_t,
}
#[test]
fn bindgen_test_layout_retro_camera_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_camera_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_camera_callback>(),
        64usize,
        concat!("Size of: ", stringify!(retro_camera_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_camera_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_camera_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).caps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(caps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_raw_framebuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(frame_raw_framebuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_opengl_texture) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(frame_opengl_texture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deinitialized) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_camera_callback),
            "::",
            stringify!(deinitialized)
        )
    );
}
#[doc = " Sets the interval of time and/or distance at which to update/poll\n location-based data.\n\n To ensure compatibility with all location-based implementations,\n values for both interval_ms and interval_distance should be provided.\n\n interval_ms is the interval expressed in milliseconds.\n interval_distance is the distance interval expressed in meters."]
pub type retro_location_set_interval_t = ::std::option::Option<
    unsafe extern "C" fn(
        interval_ms: ::std::os::raw::c_uint,
        interval_distance: ::std::os::raw::c_uint,
    ),
>;
#[doc = " Start location services. The device will start listening for changes to the\n current location at regular intervals (which are defined with\n retro_location_set_interval_t)."]
pub type retro_location_start_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[doc = " Stop location services. The device will stop listening for changes\n to the current location."]
pub type retro_location_stop_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Get the position of the current location. Will set parameters to\n 0 if no new  location update has happened since the last time."]
pub type retro_location_get_position_t = ::std::option::Option<
    unsafe extern "C" fn(
        lat: *mut f64,
        lon: *mut f64,
        horiz_accuracy: *mut f64,
        vert_accuracy: *mut f64,
    ) -> bool,
>;
#[doc = " Callback which signals when the location driver is initialized\n and/or deinitialized.\n retro_location_start_t can be called in initialized callback."]
pub type retro_location_lifetime_status_t = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_location_callback {
    pub start: retro_location_start_t,
    pub stop: retro_location_stop_t,
    pub get_position: retro_location_get_position_t,
    pub set_interval: retro_location_set_interval_t,
    pub initialized: retro_location_lifetime_status_t,
    pub deinitialized: retro_location_lifetime_status_t,
}
#[test]
fn bindgen_test_layout_retro_location_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_location_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_location_callback>(),
        48usize,
        concat!("Size of: ", stringify!(retro_location_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_location_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_location_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_location_callback),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_location_callback),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_position) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_location_callback),
            "::",
            stringify!(get_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_interval) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_location_callback),
            "::",
            stringify!(set_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_location_callback),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deinitialized) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_location_callback),
            "::",
            stringify!(deinitialized)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_rumble_effect {
    RETRO_RUMBLE_STRONG = 0,
    RETRO_RUMBLE_WEAK = 1,
    RETRO_RUMBLE_DUMMY = 2147483647,
}
#[doc = " Sets rumble state for joypad plugged in port 'port'.\n Rumble effects are controlled independently,\n and setting e.g. strong rumble does not override weak rumble.\n Strength has a range of [0, 0xffff].\n\n Returns true if rumble state request was honored.\n Calling this before first retro_run() is likely to return false."]
pub type retro_set_rumble_state_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: ::std::os::raw::c_uint,
        effect: retro_rumble_effect,
        strength: u16,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_rumble_interface {
    pub set_rumble_state: retro_set_rumble_state_t,
}
#[test]
fn bindgen_test_layout_retro_rumble_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_rumble_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_rumble_interface>(),
        8usize,
        concat!("Size of: ", stringify!(retro_rumble_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_rumble_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_rumble_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_rumble_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_rumble_interface),
            "::",
            stringify!(set_rumble_state)
        )
    );
}
#[doc = " Notifies libretro that audio data should be written."]
pub type retro_audio_callback_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " True: Audio driver in frontend is active, and callback is\n expected to be called regularily.\n False: Audio driver in frontend is paused or inactive.\n Audio callback will not be called until set_state has been\n called with true.\n Initial state is false (inactive)."]
pub type retro_audio_set_state_callback_t =
    ::std::option::Option<unsafe extern "C" fn(enabled: bool)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_audio_callback {
    pub callback: retro_audio_callback_t,
    pub set_state: retro_audio_set_state_callback_t,
}
#[test]
fn bindgen_test_layout_retro_audio_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_audio_callback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_audio_callback>(),
        16usize,
        concat!("Size of: ", stringify!(retro_audio_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_audio_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_audio_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_audio_callback),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_audio_callback),
            "::",
            stringify!(set_state)
        )
    );
}
#[doc = " Notifies a libretro core of time spent since last invocation\n of retro_run() in microseconds.\n\n It will be called right before retro_run() every frame.\n The frontend can tamper with timing to support cases like\n fast-forward, slow-motion and framestepping.\n\n In those scenarios the reference frame time value will be used."]
pub type retro_usec_t = i64;
pub type retro_frame_time_callback_t =
    ::std::option::Option<unsafe extern "C" fn(usec: retro_usec_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_frame_time_callback {
    pub callback: retro_frame_time_callback_t,
    #[doc = " Represents the time of one frame. It is computed as\n 1000000 / fps, but the implementation will resolve the\n rounding to ensure that framestepping, etc is exact."]
    pub reference: retro_usec_t,
}
#[test]
fn bindgen_test_layout_retro_frame_time_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_frame_time_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_frame_time_callback>(),
        16usize,
        concat!("Size of: ", stringify!(retro_frame_time_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_frame_time_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_frame_time_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_frame_time_callback),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reference) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_frame_time_callback),
            "::",
            stringify!(reference)
        )
    );
}
#[doc = " Notifies a libretro core of the current occupancy\n level of the frontend audio buffer.\n\n - active: 'true' if audio buffer is currently\n           in use. Will be 'false' if audio is\n           disabled in the frontend\n\n - occupancy: Given as a value in the range [0,100],\n              corresponding to the occupancy percentage\n              of the audio buffer\n\n - underrun_likely: 'true' if the frontend expects an\n                    audio buffer underrun during the\n                    next frame (indicates that a core\n                    should attempt frame skipping)\n\n It will be called right before retro_run() every frame."]
pub type retro_audio_buffer_status_callback_t = ::std::option::Option<
    unsafe extern "C" fn(active: bool, occupancy: ::std::os::raw::c_uint, underrun_likely: bool),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_audio_buffer_status_callback {
    pub callback: retro_audio_buffer_status_callback_t,
}
#[test]
fn bindgen_test_layout_retro_audio_buffer_status_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_audio_buffer_status_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_audio_buffer_status_callback>(),
        8usize,
        concat!("Size of: ", stringify!(retro_audio_buffer_status_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_audio_buffer_status_callback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(retro_audio_buffer_status_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_audio_buffer_status_callback),
            "::",
            stringify!(callback)
        )
    );
}
#[doc = " Invalidates the current HW context.\n Any GL state is lost, and must not be deinitialized explicitly.\n If explicit deinitialization is desired by the libretro core,\n it should implement context_destroy callback.\n If called, all GPU resources must be reinitialized.\n Usually called when frontend reinits video driver.\n Also called first time video driver is initialized,\n allowing libretro core to initialize resources."]
pub type retro_hw_context_reset_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Gets current framebuffer which is to be rendered to.\n Could change every frame potentially."]
pub type retro_hw_get_current_framebuffer_t =
    ::std::option::Option<unsafe extern "C" fn() -> usize>;
#[doc = " Get a symbol from HW context."]
pub type retro_hw_get_proc_address_t = ::std::option::Option<
    unsafe extern "C" fn(sym: *const ::std::os::raw::c_char) -> retro_proc_address_t,
>;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_hw_context_type {
    RETRO_HW_CONTEXT_NONE = 0,
    #[doc = " OpenGL 2.x. Driver can choose to use latest compatibility context."]
    RETRO_HW_CONTEXT_OPENGL = 1,
    #[doc = " OpenGL ES 2.0."]
    RETRO_HW_CONTEXT_OPENGLES2 = 2,
    #[doc = " Modern desktop core GL context. Use version_major/\n version_minor fields to set GL version."]
    RETRO_HW_CONTEXT_OPENGL_CORE = 3,
    #[doc = " OpenGL ES 3.0"]
    RETRO_HW_CONTEXT_OPENGLES3 = 4,
    #[doc = " OpenGL ES 3.1+. Set version_major/version_minor. For GLES2 and GLES3,\n use the corresponding enums directly."]
    RETRO_HW_CONTEXT_OPENGLES_VERSION = 5,
    #[doc = " Vulkan, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE."]
    RETRO_HW_CONTEXT_VULKAN = 6,
    #[doc = " Direct3D11, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE"]
    RETRO_HW_CONTEXT_D3D11 = 7,
    #[doc = " Direct3D10, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE"]
    RETRO_HW_CONTEXT_D3D10 = 8,
    #[doc = " Direct3D12, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE"]
    RETRO_HW_CONTEXT_D3D12 = 9,
    #[doc = " Direct3D9, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE"]
    RETRO_HW_CONTEXT_D3D9 = 10,
    #[doc = " Direct3D9, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE"]
    RETRO_HW_CONTEXT_DUMMY = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_hw_render_callback {
    #[doc = " Which API to use. Set by libretro core."]
    pub context_type: retro_hw_context_type,
    #[doc = " Called when a context has been created or when it has been reset.\n An OpenGL context is only valid after context_reset() has been called.\n\n When context_reset is called, OpenGL resources in the libretro\n implementation are guaranteed to be invalid.\n\n It is possible that context_reset is called multiple times during an\n application lifecycle.\n If context_reset is called without any notification (context_destroy),\n the OpenGL context was lost and resources should just be recreated\n without any attempt to \"free\" old resources."]
    pub context_reset: retro_hw_context_reset_t,
    #[doc = " Set by frontend.\n TODO: This is rather obsolete. The frontend should not\n be providing preallocated framebuffers."]
    pub get_current_framebuffer: retro_hw_get_current_framebuffer_t,
    #[doc = " Set by frontend.\n Can return all relevant functions, including glClear on Windows."]
    pub get_proc_address: retro_hw_get_proc_address_t,
    #[doc = " Set if render buffers should have depth component attached.\n TODO: Obsolete."]
    pub depth: bool,
    #[doc = " Set if stencil buffers should be attached.\n TODO: Obsolete."]
    pub stencil: bool,
    #[doc = " Use conventional bottom-left origin convention. If false,\n standard libretro top-left origin semantics are used.\n TODO: Move to GL specific interface."]
    pub bottom_left_origin: bool,
    #[doc = " Major version number for core GL context or GLES 3.1+."]
    pub version_major: ::std::os::raw::c_uint,
    #[doc = " Minor version number for core GL context or GLES 3.1+."]
    pub version_minor: ::std::os::raw::c_uint,
    #[doc = " If this is true, the frontend will go very far to avoid\n resetting context in scenarios like toggling fullscreen, etc.\n TODO: Obsolete? Maybe frontend should just always assume this ..."]
    pub cache_context: bool,
    #[doc = " A callback to be called before the context is destroyed in a\n controlled way by the frontend."]
    pub context_destroy: retro_hw_context_reset_t,
    #[doc = " Creates a debug context."]
    pub debug_context: bool,
}
#[test]
fn bindgen_test_layout_retro_hw_render_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_hw_render_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_hw_render_callback>(),
        64usize,
        concat!("Size of: ", stringify!(retro_hw_render_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_hw_render_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_hw_render_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(context_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_reset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(context_reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_current_framebuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(get_current_framebuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_proc_address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(get_proc_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stencil) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(stencil)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom_left_origin) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(bottom_left_origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_major) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_minor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache_context) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(cache_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_destroy) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(context_destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug_context) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_hw_render_callback),
            "::",
            stringify!(debug_context)
        )
    );
}
#[doc = " Callback type passed in RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK.\n Called by the frontend in response to keyboard events.\n down is set if the key is being pressed, or false if it is being released.\n keycode is the RETROK value of the char.\n character is the text character of the pressed key. (UTF-32).\n key_modifiers is a set of RETROKMOD values or'ed together.\n\n The pressed/keycode state can be indepedent of the character.\n It is also possible that multiple characters are generated from a\n single keypress.\n Keycode events should be treated separately from character events.\n However, when possible, the frontend should try to synchronize these.\n If only a character is posted, keycode should be RETROK_UNKNOWN.\n\n Similarily if only a keycode event is generated with no corresponding\n character, character should be 0."]
pub type retro_keyboard_event_t = ::std::option::Option<
    unsafe extern "C" fn(
        down: bool,
        keycode: ::std::os::raw::c_uint,
        character: u32,
        key_modifiers: u16,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_keyboard_callback {
    pub callback: retro_keyboard_event_t,
}
#[test]
fn bindgen_test_layout_retro_keyboard_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_keyboard_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_keyboard_callback>(),
        8usize,
        concat!("Size of: ", stringify!(retro_keyboard_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_keyboard_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_keyboard_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_keyboard_callback),
            "::",
            stringify!(callback)
        )
    );
}
#[doc = " If ejected is true, \"ejects\" the virtual disk tray.\n When ejected, the disk image index can be set."]
pub type retro_set_eject_state_t =
    ::std::option::Option<unsafe extern "C" fn(ejected: bool) -> bool>;
#[doc = " Gets current eject state. The initial state is 'not ejected'."]
pub type retro_get_eject_state_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[doc = " Gets current disk index. First disk is index 0.\n If return value is >= get_num_images(), no disk is currently inserted."]
pub type retro_get_image_index_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = " Sets image index. Can only be called when disk is ejected.\n The implementation supports setting \"no disk\" by using an\n index >= get_num_images()."]
pub type retro_set_image_index_t =
    ::std::option::Option<unsafe extern "C" fn(index: ::std::os::raw::c_uint) -> bool>;
#[doc = " Gets total number of images which are available to use."]
pub type retro_get_num_images_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = " Replaces the disk image associated with index.\n Arguments to pass in info have same requirements as retro_load_game().\n Virtual disk tray must be ejected when calling this.\n\n Replacing a disk image with info = NULL will remove the disk image\n from the internal list.\n As a result, calls to get_image_index() can change.\n\n E.g. replace_image_index(1, NULL), and previous get_image_index()\n returned 4 before.\n Index 1 will be removed, and the new index is 3."]
pub type retro_replace_image_index_t = ::std::option::Option<
    unsafe extern "C" fn(index: ::std::os::raw::c_uint, info: *const retro_game_info) -> bool,
>;
#[doc = " Adds a new valid index (get_num_images()) to the internal disk list.\n This will increment subsequent return values from get_num_images() by 1.\n This image index cannot be used until a disk image has been set\n with replace_image_index."]
pub type retro_add_image_index_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[doc = " Sets initial image to insert in drive when calling\n core_load_game().\n Since we cannot pass the initial index when loading\n content (this would require a major API change), this\n is set by the frontend *before* calling the core's\n retro_load_game()/retro_load_game_special() implementation.\n A core should therefore cache the index/path values and handle\n them inside retro_load_game()/retro_load_game_special().\n - If 'index' is invalid (index >= get_num_images()), the\n   core should ignore the set value and instead use 0\n - 'path' is used purely for error checking - i.e. when\n   content is loaded, the core should verify that the\n   disk specified by 'index' has the specified file path.\n   This is to guard against auto selecting the wrong image\n   if (for example) the user should modify an existing M3U\n   playlist. We have to let the core handle this because\n   set_initial_image() must be called before loading content,\n   i.e. the frontend cannot access image paths in advance\n   and thus cannot perform the error check itself.\n   If set path and content path do not match, the core should\n   ignore the set 'index' value and instead use 0\n Returns 'false' if index or 'path' are invalid, or core\n does not support this functionality"]
pub type retro_set_initial_image_t = ::std::option::Option<
    unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        path: *const ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " Fetches the path of the specified disk image file.\n Returns 'false' if index is invalid (index >= get_num_images())\n or path is otherwise unavailable."]
pub type retro_get_image_path_t = ::std::option::Option<
    unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        path: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> bool,
>;
#[doc = " Fetches a core-provided 'label' for the specified disk\n image file. In the simplest case this may be a file name\n (without extension), but for cores with more complex\n content requirements information may be provided to\n facilitate user disk swapping - for example, a core\n running floppy-disk-based content may uniquely label\n save disks, data disks, level disks, etc. with names\n corresponding to in-game disk change prompts (so the\n frontend can provide better user guidance than a 'dumb'\n disk index value).\n Returns 'false' if index is invalid (index >= get_num_images())\n or label is otherwise unavailable."]
pub type retro_get_image_label_t = ::std::option::Option<
    unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        label: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_disk_control_callback {
    pub set_eject_state: retro_set_eject_state_t,
    pub get_eject_state: retro_get_eject_state_t,
    pub get_image_index: retro_get_image_index_t,
    pub set_image_index: retro_set_image_index_t,
    pub get_num_images: retro_get_num_images_t,
    pub replace_image_index: retro_replace_image_index_t,
    pub add_image_index: retro_add_image_index_t,
}
#[test]
fn bindgen_test_layout_retro_disk_control_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_disk_control_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_disk_control_callback>(),
        56usize,
        concat!("Size of: ", stringify!(retro_disk_control_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_disk_control_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_disk_control_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_eject_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_callback),
            "::",
            stringify!(set_eject_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_eject_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_callback),
            "::",
            stringify!(get_eject_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_image_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_callback),
            "::",
            stringify!(get_image_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_image_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_callback),
            "::",
            stringify!(set_image_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_num_images) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_callback),
            "::",
            stringify!(get_num_images)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_image_index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_callback),
            "::",
            stringify!(replace_image_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_image_index) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_callback),
            "::",
            stringify!(add_image_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_disk_control_ext_callback {
    pub set_eject_state: retro_set_eject_state_t,
    pub get_eject_state: retro_get_eject_state_t,
    pub get_image_index: retro_get_image_index_t,
    pub set_image_index: retro_set_image_index_t,
    pub get_num_images: retro_get_num_images_t,
    pub replace_image_index: retro_replace_image_index_t,
    pub add_image_index: retro_add_image_index_t,
    #[doc = " Optional - may be NULL"]
    pub set_initial_image: retro_set_initial_image_t,
    #[doc = " Optional - may be NULL"]
    pub get_image_path: retro_get_image_path_t,
    #[doc = " Optional - may be NULL"]
    pub get_image_label: retro_get_image_label_t,
}
#[test]
fn bindgen_test_layout_retro_disk_control_ext_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_disk_control_ext_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_disk_control_ext_callback>(),
        80usize,
        concat!("Size of: ", stringify!(retro_disk_control_ext_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_disk_control_ext_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_disk_control_ext_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_eject_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(set_eject_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_eject_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(get_eject_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_image_index) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(get_image_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_image_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(set_image_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_num_images) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(get_num_images)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_image_index) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(replace_image_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_image_index) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(add_image_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_initial_image) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(set_initial_image)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_image_path) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(get_image_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_image_label) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_disk_control_ext_callback),
            "::",
            stringify!(get_image_label)
        )
    );
}
#[doc = " Used by the core to send a packet to one or more connected players.\n A single packet sent via this interface can contain up to 64 KB of data.\n\n The broadcast flag can be set to true to send to multiple connected clients.\n In a broadcast, the client_id argument indicates 1 client NOT to send the\n packet to (pass 0xFFFF to send to everyone). Otherwise, the client_id\n argument indicates a single client to send the packet to.\n\n A frontend must support sending reliable packets (RETRO_NETPACKET_RELIABLE).\n Unreliable packets might not be supported by the frontend, but the flags can\n still be specified. Reliable transmission will be used instead.\n\n If this function is called passing NULL for buf, it will instead flush all\n previously buffered outgoing packets and instantly read any incoming packets.\n During such a call, retro_netpacket_receive_t and retro_netpacket_stop_t can\n be called. The core can perform this in a loop to do a blocking read, i.e.,\n wait for incoming data, but needs to handle stop getting called and also\n give up after a short while to avoid freezing on a connection problem.\n\n This function is not guaranteed to be thread-safe and must be called during\n retro_run or any of the netpacket callbacks passed with this interface."]
pub type retro_netpacket_send_t = ::std::option::Option<
    unsafe extern "C" fn(
        flags: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: usize,
        client_id: u16,
        broadcast: bool,
    ),
>;
#[doc = " Called by the frontend to signify that a multiplayer session has started.\n If client_id is 0 the local player is the host of the session and at this\n point no other player has connected yet.\n\n If client_id is > 0 the local player is a client connected to a host and\n at this point is already fully connected to the host.\n\n The core must store the retro_netpacket_send_t function pointer provided\n here and use it whenever it wants to send a packet. This function pointer\n remains valid until the frontend calls retro_netpacket_stop_t."]
pub type retro_netpacket_start_t =
    ::std::option::Option<unsafe extern "C" fn(client_id: u16, send_fn: retro_netpacket_send_t)>;
#[doc = " Called by the frontend when a new packet arrives which has been sent from\n another player with retro_netpacket_send_t. The client_id argument indicates\n who has sent the packet."]
pub type retro_netpacket_receive_t = ::std::option::Option<
    unsafe extern "C" fn(buf: *const ::std::os::raw::c_void, len: usize, client_id: u16),
>;
#[doc = " Called by the frontend when the multiplayer session has ended.\n Once this gets called the retro_netpacket_send_t function pointer passed\n to retro_netpacket_start_t will not be valid anymore."]
pub type retro_netpacket_stop_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Called by the frontend every frame (between calls to retro_run while\n updating the state of the multiplayer session.\n This is a good place for the core to call retro_netpacket_send_t from."]
pub type retro_netpacket_poll_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Called by the frontend when a new player connects to the hosted session.\n This is only called on the host side, not for clients connected to the host.\n If this function returns false, the newly connected player gets dropped.\n This can be used for example to limit the number of players."]
pub type retro_netpacket_connected_t =
    ::std::option::Option<unsafe extern "C" fn(client_id: u16) -> bool>;
#[doc = " Called by the frontend when a player leaves or disconnects from the hosted session.\n This is only called on the host side, not for clients connected to the host."]
pub type retro_netpacket_disconnected_t =
    ::std::option::Option<unsafe extern "C" fn(client_id: u16)>;
#[doc = " A callback interface for giving a core the ability to send and receive custom\n network packets during a multiplayer session between two or more instances\n of a libretro frontend.\n\n @see RETRO_ENVIRONMENT_SET_NETPACKET_INTERFACE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_netpacket_callback {
    pub start: retro_netpacket_start_t,
    pub receive: retro_netpacket_receive_t,
    #[doc = " Optional - may be NULL"]
    pub stop: retro_netpacket_stop_t,
    #[doc = " Optional - may be NULL"]
    pub poll: retro_netpacket_poll_t,
    #[doc = " Optional - may be NULL"]
    pub connected: retro_netpacket_connected_t,
    #[doc = " Optional - may be NULL"]
    pub disconnected: retro_netpacket_disconnected_t,
}
#[test]
fn bindgen_test_layout_retro_netpacket_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_netpacket_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_netpacket_callback>(),
        48usize,
        concat!("Size of: ", stringify!(retro_netpacket_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_netpacket_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_netpacket_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_netpacket_callback),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_netpacket_callback),
            "::",
            stringify!(receive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_netpacket_callback),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_netpacket_callback),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connected) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_netpacket_callback),
            "::",
            stringify!(connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnected) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_netpacket_callback),
            "::",
            stringify!(disconnected)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_pixel_format {
    #[doc = " 0RGB1555, native endian.\n 0 bit must be set to 0.\n This pixel format is default for compatibility concerns only.\n If a 15/16-bit pixel format is desired, consider using RGB565."]
    RETRO_PIXEL_FORMAT_0RGB1555 = 0,
    #[doc = " XRGB8888, native endian.\n X bits are ignored."]
    RETRO_PIXEL_FORMAT_XRGB8888 = 1,
    #[doc = " RGB565, native endian.\n This pixel format is the recommended format to use if a 15/16-bit\n format is desired as it is the pixel format that is typically\n available on a wide range of low-power devices.\n\n It is also natively supported in APIs like OpenGL ES."]
    RETRO_PIXEL_FORMAT_RGB565 = 2,
    #[doc = " Ensure sizeof() == sizeof(int)."]
    RETRO_PIXEL_FORMAT_UNKNOWN = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_savestate_context {
    #[doc = " Standard savestate written to disk."]
    RETRO_SAVESTATE_CONTEXT_NORMAL = 0,
    #[doc = " Savestate where you are guaranteed that the same instance will load the save state.\n You can store internal pointers to code or data.\n It's still a full serialization and deserialization, and could be loaded or saved at any time.\n It won't be written to disk or sent over the network."]
    RETRO_SAVESTATE_CONTEXT_RUNAHEAD_SAME_INSTANCE = 1,
    #[doc = " Savestate where you are guaranteed that the same emulator binary will load that savestate.\n You can skip anything that would slow down saving or loading state but you can not store internal pointers.\n It won't be written to disk or sent over the network.\n Example: \"Second Instance\" runahead"]
    RETRO_SAVESTATE_CONTEXT_RUNAHEAD_SAME_BINARY = 2,
    #[doc = " Savestate used within a rollback netplay feature.\n You should skip anything that would unnecessarily increase bandwidth usage.\n It won't be written to disk but it will be sent over the network."]
    RETRO_SAVESTATE_CONTEXT_ROLLBACK_NETPLAY = 3,
    #[doc = " Ensure sizeof() == sizeof(int)."]
    RETRO_SAVESTATE_CONTEXT_UNKNOWN = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_message {
    #[doc = " Message to be displayed."]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = " Duration in frames of message."]
    pub frames: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_message() {
    const UNINIT: ::std::mem::MaybeUninit<retro_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_message>(),
        16usize,
        concat!("Size of: ", stringify!(retro_message))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_message>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message),
            "::",
            stringify!(frames)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_message_target {
    RETRO_MESSAGE_TARGET_ALL = 0,
    RETRO_MESSAGE_TARGET_OSD = 1,
    RETRO_MESSAGE_TARGET_LOG = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_message_type {
    RETRO_MESSAGE_TYPE_NOTIFICATION = 0,
    RETRO_MESSAGE_TYPE_NOTIFICATION_ALT = 1,
    RETRO_MESSAGE_TYPE_STATUS = 2,
    RETRO_MESSAGE_TYPE_PROGRESS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_message_ext {
    #[doc = " Message string to be displayed/logged"]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = " Duration (in ms) of message when targeting the OSD"]
    pub duration: ::std::os::raw::c_uint,
    #[doc = " Message priority when targeting the OSD\n > When multiple concurrent messages are sent to\n   the frontend and the frontend does not have the\n   capacity to display them all, messages with the\n   *highest* priority value should be shown\n > There is no upper limit to a message priority\n   value (within the bounds of the unsigned data type)\n > In the reference frontend (RetroArch), the same\n   priority values are used for frontend-generated\n   notifications, which are typically assigned values\n   between 0 and 3 depending upon importance"]
    pub priority: ::std::os::raw::c_uint,
    #[doc = " Message logging level (info, warn, error, etc.)"]
    pub level: retro_log_level,
    #[doc = " Message destination: OSD, logging interface or both"]
    pub target: retro_message_target,
    #[doc = " Message 'type' when targeting the OSD\n > RETRO_MESSAGE_TYPE_NOTIFICATION: Specifies that a\n   message should be handled in identical fashion to\n   a standard frontend-generated notification\n > RETRO_MESSAGE_TYPE_NOTIFICATION_ALT: Specifies that\n   message is a notification that requires user attention\n   or action, but that it should be displayed in a manner\n   that differs from standard frontend-generated notifications.\n   This would typically correspond to messages that should be\n   displayed immediately (independently from any internal\n   frontend message queue), and/or which should be visually\n   distinguishable from frontend-generated notifications.\n   For example, a core may wish to inform the user of\n   information related to a disk-change event. It is\n   expected that the frontend itself may provide a\n   notification in this case; if the core sends a\n   message of type RETRO_MESSAGE_TYPE_NOTIFICATION, an\n   uncomfortable 'double-notification' may occur. A message\n   of RETRO_MESSAGE_TYPE_NOTIFICATION_ALT should therefore\n   be presented such that visual conflict with regular\n   notifications does not occur\n > RETRO_MESSAGE_TYPE_STATUS: Indicates that message\n   is not a standard notification. This typically\n   corresponds to 'status' indicators, such as a core's\n   internal FPS, which are intended to be displayed\n   either permanently while a core is running, or in\n   a manner that does not suggest user attention or action\n   is required. 'Status' type messages should therefore be\n   displayed in a different on-screen location and in a manner\n   easily distinguishable from both standard frontend-generated\n   notifications and messages of type RETRO_MESSAGE_TYPE_NOTIFICATION_ALT\n > RETRO_MESSAGE_TYPE_PROGRESS: Indicates that message reports\n   the progress of an internal core task. For example, in cases\n   where a core itself handles the loading of content from a file,\n   this may correspond to the percentage of the file that has been\n   read. Alternatively, an audio/video playback core may use a\n   message of type RETRO_MESSAGE_TYPE_PROGRESS to display the current\n   playback position as a percentage of the runtime. 'Progress' type\n   messages should therefore be displayed as a literal progress bar,\n   where:\n   - 'retro_message_ext.msg' is the progress bar title/label\n   - 'retro_message_ext.progress' determines the length of\n     the progress bar\n NOTE: Message type is a *hint*, and may be ignored\n by the frontend. If a frontend lacks support for\n displaying messages via alternate means than standard\n frontend-generated notifications, it will treat *all*\n messages as having the type RETRO_MESSAGE_TYPE_NOTIFICATION"]
    pub type_: retro_message_type,
    #[doc = " Task progress when targeting the OSD and message is\n of type RETRO_MESSAGE_TYPE_PROGRESS\n > -1:    Unmetered/indeterminate\n > 0-100: Current progress percentage\n NOTE: Since message type is a hint, a frontend may ignore\n progress values. Where relevant, a core should therefore\n include progress percentage within the message string,\n such that the message intent remains clear when displayed\n as a standard frontend-generated notification"]
    pub progress: i8,
}
#[test]
fn bindgen_test_layout_retro_message_ext() {
    const UNINIT: ::std::mem::MaybeUninit<retro_message_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_message_ext>(),
        32usize,
        concat!("Size of: ", stringify!(retro_message_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_message_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_message_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message_ext),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message_ext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message_ext),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message_ext),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message_ext),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message_ext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).progress) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_message_ext),
            "::",
            stringify!(progress)
        )
    );
}
#[doc = " Describes how the libretro implementation maps a libretro input bind\n to its internal input system through a human readable string.\n This string can be used to better let a user configure input."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_input_descriptor {
    #[doc = " Associates given parameters with a description."]
    pub port: ::std::os::raw::c_uint,
    pub device: ::std::os::raw::c_uint,
    pub index: ::std::os::raw::c_uint,
    pub id: ::std::os::raw::c_uint,
    #[doc = " Human readable description for parameters.\n The pointer must remain valid until\n retro_unload_game() is called."]
    pub description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_input_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<retro_input_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_input_descriptor>(),
        24usize,
        concat!("Size of: ", stringify!(retro_input_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_input_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_input_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_input_descriptor),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_input_descriptor),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_input_descriptor),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_input_descriptor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_input_descriptor),
            "::",
            stringify!(description)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_system_info {
    #[doc = " Descriptive name of library. Should not\n contain any version numbers, etc."]
    pub library_name: *const ::std::os::raw::c_char,
    #[doc = " Descriptive version of core."]
    pub library_version: *const ::std::os::raw::c_char,
    #[doc = " A string listing probably content\n extensions the core will be able to\n load, separated with pipe.\n I.e. \"bin|rom|iso\".\n Typically used for a GUI to filter\n out extensions."]
    pub valid_extensions: *const ::std::os::raw::c_char,
    #[doc = " Libretro cores that need to have direct access to their content\n files, including cores which use the path of the content files to\n determine the paths of other files, should set need_fullpath to true.\n\n Cores should strive for setting need_fullpath to false,\n as it allows the frontend to perform patching, etc.\n\n If need_fullpath is true and retro_load_game() is called:\n    - retro_game_info::path is guaranteed to have a valid path\n    - retro_game_info::data and retro_game_info::size are invalid\n\n If need_fullpath is false and retro_load_game() is called:\n    - retro_game_info::path may be NULL\n    - retro_game_info::data and retro_game_info::size are guaranteed\n      to be valid\n\n See also:\n    - RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY\n    - RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY"]
    pub need_fullpath: bool,
    #[doc = " If true, the frontend is not allowed to extract any archives before\n loading the real content.\n Necessary for certain libretro implementations that load games\n from zipped archives."]
    pub block_extract: bool,
}
#[test]
fn bindgen_test_layout_retro_system_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_system_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_system_info>(),
        32usize,
        concat!("Size of: ", stringify!(retro_system_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_system_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_system_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).library_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_info),
            "::",
            stringify!(library_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).library_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_info),
            "::",
            stringify!(library_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid_extensions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_info),
            "::",
            stringify!(valid_extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).need_fullpath) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_info),
            "::",
            stringify!(need_fullpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_extract) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_info),
            "::",
            stringify!(block_extract)
        )
    );
}
#[doc = " Defines overrides which modify frontend handling of\n specific content file types.\n An array of retro_system_content_info_override is\n passed to RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE\n NOTE: In the following descriptions, references to\n       retro_load_game() may be replaced with\n       retro_load_game_special()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_system_content_info_override {
    #[doc = " A list of file extensions for which the override\n should apply, delimited by a 'pipe' character\n (e.g. \"md|sms|gg\")\n Permitted file extensions are limited to those\n included in retro_system_info::valid_extensions\n and/or retro_subsystem_rom_info::valid_extensions"]
    pub extensions: *const ::std::os::raw::c_char,
    #[doc = " Overrides the need_fullpath value set in\n retro_system_info and/or retro_subsystem_rom_info.\n To reiterate:\n\n If need_fullpath is true and retro_load_game() is called:\n    - retro_game_info::path is guaranteed to contain a valid\n      path to an existent file\n    - retro_game_info::data and retro_game_info::size are invalid\n\n If need_fullpath is false and retro_load_game() is called:\n    - retro_game_info::path may be NULL\n    - retro_game_info::data and retro_game_info::size are guaranteed\n      to be valid\n\n In addition:\n\n If need_fullpath is true and retro_load_game() is called:\n    - retro_game_info_ext::full_path is guaranteed to contain a valid\n      path to an existent file\n    - retro_game_info_ext::archive_path may be NULL\n    - retro_game_info_ext::archive_file may be NULL\n    - retro_game_info_ext::dir is guaranteed to contain a valid path\n      to the directory in which the content file exists\n    - retro_game_info_ext::name is guaranteed to contain the\n      basename of the content file, without extension\n    - retro_game_info_ext::ext is guaranteed to contain the\n      extension of the content file in lower case format\n    - retro_game_info_ext::data and retro_game_info_ext::size\n      are invalid\n\n If need_fullpath is false and retro_load_game() is called:\n    - If retro_game_info_ext::file_in_archive is false:\n       - retro_game_info_ext::full_path is guaranteed to contain\n         a valid path to an existent file\n       - retro_game_info_ext::archive_path may be NULL\n       - retro_game_info_ext::archive_file may be NULL\n       - retro_game_info_ext::dir is guaranteed to contain a\n         valid path to the directory in which the content file exists\n       - retro_game_info_ext::name is guaranteed to contain the\n         basename of the content file, without extension\n       - retro_game_info_ext::ext is guaranteed to contain the\n         extension of the content file in lower case format\n    - If retro_game_info_ext::file_in_archive is true:\n       - retro_game_info_ext::full_path may be NULL\n       - retro_game_info_ext::archive_path is guaranteed to\n         contain a valid path to an existent compressed file\n         inside which the content file is located\n       - retro_game_info_ext::archive_file is guaranteed to\n         contain a valid path to an existent content file\n         inside the compressed file referred to by\n         retro_game_info_ext::archive_path\n            e.g. for a compressed file '/path/to/foo.zip'\n            containing 'bar.sfc'\n             > retro_game_info_ext::archive_path will be '/path/to/foo.zip'\n             > retro_game_info_ext::archive_file will be 'bar.sfc'\n       - retro_game_info_ext::dir is guaranteed to contain a\n         valid path to the directory in which the compressed file\n         (containing the content file) exists\n       - retro_game_info_ext::name is guaranteed to contain\n         EITHER\n         1) the basename of the compressed file (containing\n            the content file), without extension\n         OR\n         2) the basename of the content file inside the\n            compressed file, without extension\n         In either case, a core should consider 'name' to\n         be the canonical name/ID of the the content file\n       - retro_game_info_ext::ext is guaranteed to contain the\n         extension of the content file inside the compressed file,\n         in lower case format\n    - retro_game_info_ext::data and retro_game_info_ext::size are\n      guaranteed to be valid"]
    pub need_fullpath: bool,
    #[doc = " If need_fullpath is false, specifies whether the content\n data buffer available in retro_load_game() is 'persistent'\n\n If persistent_data is false and retro_load_game() is called:\n    - retro_game_info::data and retro_game_info::size\n      are valid only until retro_load_game() returns\n    - retro_game_info_ext::data and retro_game_info_ext::size\n      are valid only until retro_load_game() returns\n\n If persistent_data is true and retro_load_game() is called:\n    - retro_game_info::data and retro_game_info::size\n      are valid until retro_deinit() returns\n    - retro_game_info_ext::data and retro_game_info_ext::size\n      are valid until retro_deinit() returns"]
    pub persistent_data: bool,
}
#[test]
fn bindgen_test_layout_retro_system_content_info_override() {
    const UNINIT: ::std::mem::MaybeUninit<retro_system_content_info_override> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_system_content_info_override>(),
        16usize,
        concat!("Size of: ", stringify!(retro_system_content_info_override))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_system_content_info_override>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(retro_system_content_info_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_content_info_override),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).need_fullpath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_content_info_override),
            "::",
            stringify!(need_fullpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persistent_data) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_content_info_override),
            "::",
            stringify!(persistent_data)
        )
    );
}
#[doc = " Similar to retro_game_info, but provides extended\n information about the source content file and\n game memory buffer status.\n And array of retro_game_info_ext is returned by\n RETRO_ENVIRONMENT_GET_GAME_INFO_EXT\n NOTE: In the following descriptions, references to\n       retro_load_game() may be replaced with\n       retro_load_game_special()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_game_info_ext {
    #[doc = " - If file_in_archive is false, contains a valid\n   path to an existent content file (UTF-8 encoded)\n - If file_in_archive is true, may be NULL"]
    pub full_path: *const ::std::os::raw::c_char,
    #[doc = " - If file_in_archive is false, may be NULL\n - If file_in_archive is true, contains a valid path\n   to an existent compressed file inside which the\n   content file is located (UTF-8 encoded)"]
    pub archive_path: *const ::std::os::raw::c_char,
    #[doc = " - If file_in_archive is false, may be NULL\n - If file_in_archive is true, contain a valid path\n   to an existent content file inside the compressed\n   file referred to by archive_path (UTF-8 encoded)\n      e.g. for a compressed file '/path/to/foo.zip'\n      containing 'bar.sfc'\n      > archive_path will be '/path/to/foo.zip'\n      > archive_file will be 'bar.sfc'"]
    pub archive_file: *const ::std::os::raw::c_char,
    #[doc = " - If file_in_archive is false, contains a valid path\n   to the directory in which the content file exists\n   (UTF-8 encoded)\n - If file_in_archive is true, contains a valid path\n   to the directory in which the compressed file\n   (containing the content file) exists (UTF-8 encoded)"]
    pub dir: *const ::std::os::raw::c_char,
    #[doc = " Contains the canonical name/ID of the content file\n (UTF-8 encoded). Intended for use when identifying\n 'complementary' content named after the loaded file -\n i.e. companion data of a different format (a CD image\n required by a ROM), texture packs, internally handled\n save files, etc.\n - If file_in_archive is false, contains the basename\n   of the content file, without extension\n - If file_in_archive is true, then string is\n   implementation specific. A frontend may choose to\n   set a name value of:\n   EITHER\n   1) the basename of the compressed file (containing\n      the content file), without extension\n   OR\n   2) the basename of the content file inside the\n      compressed file, without extension\n   RetroArch sets the 'name' value according to (1).\n   A frontend that supports routine loading of\n   content from archives containing multiple unrelated\n   content files may set the 'name' value according\n   to (2)."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " - If file_in_archive is false, contains the extension\n   of the content file in lower case format\n - If file_in_archive is true, contains the extension\n   of the content file inside the compressed file,\n   in lower case format"]
    pub ext: *const ::std::os::raw::c_char,
    #[doc = " String of implementation specific meta-data."]
    pub meta: *const ::std::os::raw::c_char,
    #[doc = " Memory buffer of loaded game content. Will be NULL:\n IF\n - retro_system_info::need_fullpath is true and\n   retro_system_content_info_override::need_fullpath\n   is unset\n OR\n - retro_system_content_info_override::need_fullpath\n   is true"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Size of game content memory buffer, in bytes"]
    pub size: usize,
    #[doc = " True if loaded content file is inside a compressed\n archive"]
    pub file_in_archive: bool,
    #[doc = " - If data is NULL, value is unset/ignored\n - If data is non-NULL:\n   - If persistent_data is false, data and size are\n     valid only until retro_load_game() returns\n   - If persistent_data is true, data and size are\n     are valid until retro_deinit() returns"]
    pub persistent_data: bool,
}
#[test]
fn bindgen_test_layout_retro_game_info_ext() {
    const UNINIT: ::std::mem::MaybeUninit<retro_game_info_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_game_info_ext>(),
        80usize,
        concat!("Size of: ", stringify!(retro_game_info_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_game_info_ext>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_game_info_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(full_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).archive_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(archive_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).archive_file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(archive_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ext) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_in_archive) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(file_in_archive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persistent_data) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info_ext),
            "::",
            stringify!(persistent_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_game_geometry {
    #[doc = " Nominal video width of game."]
    pub base_width: ::std::os::raw::c_uint,
    #[doc = " Nominal video height of game."]
    pub base_height: ::std::os::raw::c_uint,
    #[doc = " Maximum possible width of game."]
    pub max_width: ::std::os::raw::c_uint,
    #[doc = " Maximum possible height of game."]
    pub max_height: ::std::os::raw::c_uint,
    #[doc = " Nominal aspect ratio of game. If\n aspect_ratio is <= 0.0, an aspect ratio\n of base_width / base_height is assumed.\n A frontend could override this setting,\n if desired."]
    pub aspect_ratio: f32,
}
#[test]
fn bindgen_test_layout_retro_game_geometry() {
    const UNINIT: ::std::mem::MaybeUninit<retro_game_geometry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_game_geometry>(),
        20usize,
        concat!("Size of: ", stringify!(retro_game_geometry))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_game_geometry>(),
        4usize,
        concat!("Alignment of ", stringify!(retro_game_geometry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_geometry),
            "::",
            stringify!(base_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_geometry),
            "::",
            stringify!(base_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_geometry),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_geometry),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect_ratio) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_geometry),
            "::",
            stringify!(aspect_ratio)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_system_timing {
    #[doc = " FPS of video content."]
    pub fps: f64,
    #[doc = " Sampling rate of audio."]
    pub sample_rate: f64,
}
#[test]
fn bindgen_test_layout_retro_system_timing() {
    const UNINIT: ::std::mem::MaybeUninit<retro_system_timing> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_system_timing>(),
        16usize,
        concat!("Size of: ", stringify!(retro_system_timing))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_system_timing>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_system_timing))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_timing),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_timing),
            "::",
            stringify!(sample_rate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_system_av_info {
    pub geometry: retro_game_geometry,
    pub timing: retro_system_timing,
}
#[test]
fn bindgen_test_layout_retro_system_av_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_system_av_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_system_av_info>(),
        40usize,
        concat!("Size of: ", stringify!(retro_system_av_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_system_av_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_system_av_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geometry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_av_info),
            "::",
            stringify!(geometry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_system_av_info),
            "::",
            stringify!(timing)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_variable {
    #[doc = " Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE.\n If NULL, obtains the complete environment string if more\n complex parsing is necessary.\n The environment string is formatted as key-value pairs\n delimited by semicolons as so:\n \"key1=value1;key2=value2;...\""]
    pub key: *const ::std::os::raw::c_char,
    #[doc = " Value to be obtained. If key does not exist, it is set to NULL."]
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_variable() {
    const UNINIT: ::std::mem::MaybeUninit<retro_variable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_variable>(),
        16usize,
        concat!("Size of: ", stringify!(retro_variable))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_variable>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_variable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_variable),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_variable),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_option_display {
    #[doc = " Variable to configure in RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY"]
    pub key: *const ::std::os::raw::c_char,
    #[doc = " Specifies whether variable should be displayed\n when presenting core options to the user"]
    pub visible: bool,
}
#[test]
fn bindgen_test_layout_retro_core_option_display() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_option_display> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_option_display>(),
        16usize,
        concat!("Size of: ", stringify!(retro_core_option_display))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_option_display>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_option_display))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_display),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_display),
            "::",
            stringify!(visible)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_option_value {
    #[doc = " Expected option value"]
    pub value: *const ::std::os::raw::c_char,
    #[doc = " Human-readable value label. If NULL, value itself\n will be displayed by the frontend"]
    pub label: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_core_option_value() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_option_value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_option_value>(),
        16usize,
        concat!("Size of: ", stringify!(retro_core_option_value))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_option_value>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_option_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_value),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_value),
            "::",
            stringify!(label)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_option_definition {
    #[doc = " Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE."]
    pub key: *const ::std::os::raw::c_char,
    #[doc = " Human-readable core option description (used as menu label)"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " Human-readable core option information (used as menu sublabel)"]
    pub info: *const ::std::os::raw::c_char,
    #[doc = " Array of retro_core_option_value structs, terminated by NULL"]
    pub values: [retro_core_option_value; 128usize],
    #[doc = " Default core option value. Must match one of the values\n in the retro_core_option_value array, otherwise will be\n ignored"]
    pub default_value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_core_option_definition() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_option_definition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_option_definition>(),
        2080usize,
        concat!("Size of: ", stringify!(retro_core_option_definition))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_option_definition>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_option_definition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_definition),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_definition),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_definition),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_definition),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_definition),
            "::",
            stringify!(default_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_options_intl {
    #[doc = " Pointer to an array of retro_core_option_definition structs\n - US English implementation\n - Must point to a valid array"]
    pub us: *mut retro_core_option_definition,
    #[doc = " Pointer to an array of retro_core_option_definition structs\n - Implementation for current frontend language\n - May be NULL"]
    pub local: *mut retro_core_option_definition,
}
#[test]
fn bindgen_test_layout_retro_core_options_intl() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_options_intl> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_options_intl>(),
        16usize,
        concat!("Size of: ", stringify!(retro_core_options_intl))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_options_intl>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_options_intl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_options_intl),
            "::",
            stringify!(us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_options_intl),
            "::",
            stringify!(local)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_option_v2_category {
    #[doc = " Variable uniquely identifying the\n option category. Valid key characters\n are [a-z, A-Z, 0-9, _, -]"]
    pub key: *const ::std::os::raw::c_char,
    #[doc = " Human-readable category description\n > Used as category menu label when\n   frontend has core option category\n   support"]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " Human-readable category information\n > Used as category menu sublabel when\n   frontend has core option category\n   support\n > Optional (may be NULL or an empty\n   string)"]
    pub info: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_core_option_v2_category() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_option_v2_category> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_option_v2_category>(),
        24usize,
        concat!("Size of: ", stringify!(retro_core_option_v2_category))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_option_v2_category>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_option_v2_category))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_category),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_category),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_category),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_option_v2_definition {
    #[doc = " Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE.\n Valid key characters are [a-z, A-Z, 0-9, _, -]"]
    pub key: *const ::std::os::raw::c_char,
    #[doc = " Human-readable core option description\n > Used as menu label when frontend does\n   not have core option category support\n   e.g. \"Video > Aspect Ratio\""]
    pub desc: *const ::std::os::raw::c_char,
    #[doc = " Human-readable core option description\n > Used as menu label when frontend has\n   core option category support\n   e.g. \"Aspect Ratio\", where associated\n   retro_core_option_v2_category::desc\n   is \"Video\"\n > If empty or NULL, the string specified by\n   desc will be used as the menu label\n > Will be ignored (and may be set to NULL)\n   if category_key is empty or NULL"]
    pub desc_categorized: *const ::std::os::raw::c_char,
    #[doc = " Human-readable core option information\n > Used as menu sublabel"]
    pub info: *const ::std::os::raw::c_char,
    #[doc = " Human-readable core option information\n > Used as menu sublabel when frontend\n   has core option category support\n   (e.g. may be required when info text\n   references an option by name/desc,\n   and the desc/desc_categorized text\n   for that option differ)\n > If empty or NULL, the string specified by\n   info will be used as the menu sublabel\n > Will be ignored (and may be set to NULL)\n   if category_key is empty or NULL"]
    pub info_categorized: *const ::std::os::raw::c_char,
    #[doc = " Variable specifying category (e.g. \"video\",\n \"audio\") that will be assigned to the option\n if frontend has core option category support.\n > Categorized options will be displayed in a\n   subsection/submenu of the frontend core\n   option interface\n > Specified string must match one of the\n   retro_core_option_v2_category::key values\n   in the associated retro_core_option_v2_category\n   array; If no match is not found, specified\n   string will be considered as NULL\n > If specified string is empty or NULL, option will\n   have no category and will be shown at the top\n   level of the frontend core option interface"]
    pub category_key: *const ::std::os::raw::c_char,
    #[doc = " Array of retro_core_option_value structs, terminated by NULL"]
    pub values: [retro_core_option_value; 128usize],
    #[doc = " Default core option value. Must match one of the values\n in the retro_core_option_value array, otherwise will be\n ignored"]
    pub default_value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_core_option_v2_definition() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_option_v2_definition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_option_v2_definition>(),
        2104usize,
        concat!("Size of: ", stringify!(retro_core_option_v2_definition))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_option_v2_definition>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_option_v2_definition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desc_categorized) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(desc_categorized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_categorized) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(info_categorized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category_key) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(category_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_option_v2_definition),
            "::",
            stringify!(default_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_options_v2 {
    #[doc = " Array of retro_core_option_v2_category structs,\n terminated by NULL\n > If NULL, all entries in definitions array\n   will have no category and will be shown at\n   the top level of the frontend core option\n   interface\n > Will be ignored if frontend does not have\n   core option category support"]
    pub categories: *mut retro_core_option_v2_category,
    #[doc = " Array of retro_core_option_v2_definition structs,\n terminated by NULL"]
    pub definitions: *mut retro_core_option_v2_definition,
}
#[test]
fn bindgen_test_layout_retro_core_options_v2() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_options_v2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_options_v2>(),
        16usize,
        concat!("Size of: ", stringify!(retro_core_options_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_options_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_options_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).categories) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_options_v2),
            "::",
            stringify!(categories)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).definitions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_options_v2),
            "::",
            stringify!(definitions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_options_v2_intl {
    #[doc = " Pointer to a retro_core_options_v2 struct\n > US English implementation\n > Must point to a valid struct"]
    pub us: *mut retro_core_options_v2,
    #[doc = " Pointer to a retro_core_options_v2 struct\n - Implementation for current frontend language\n - May be NULL"]
    pub local: *mut retro_core_options_v2,
}
#[test]
fn bindgen_test_layout_retro_core_options_v2_intl() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_options_v2_intl> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_options_v2_intl>(),
        16usize,
        concat!("Size of: ", stringify!(retro_core_options_v2_intl))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_options_v2_intl>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_core_options_v2_intl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_options_v2_intl),
            "::",
            stringify!(us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_options_v2_intl),
            "::",
            stringify!(local)
        )
    );
}
#[doc = " Used by the frontend to monitor changes in core option\n visibility. May be called each time any core option\n value is set via the frontend.\n - On each invocation, the core must update the visibility\n   of any dynamically hidden options using the\n   RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY environment\n   callback.\n - On the first invocation, returns 'true' if the visibility\n   of any core option has changed since the last call of\n   retro_load_game() or retro_load_game_special().\n - On each subsequent invocation, returns 'true' if the\n   visibility of any core option has changed since the last\n   time the function was called."]
pub type retro_core_options_update_display_callback_t =
    ::std::option::Option<unsafe extern "C" fn() -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_core_options_update_display_callback {
    pub callback: retro_core_options_update_display_callback_t,
}
#[test]
fn bindgen_test_layout_retro_core_options_update_display_callback() {
    const UNINIT: ::std::mem::MaybeUninit<retro_core_options_update_display_callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_core_options_update_display_callback>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(retro_core_options_update_display_callback)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<retro_core_options_update_display_callback>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(retro_core_options_update_display_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_core_options_update_display_callback),
            "::",
            stringify!(callback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_game_info {
    #[doc = " Path to game, UTF-8 encoded.\n Sometimes used as a reference for building other paths.\n May be NULL if game was loaded from stdin or similar,\n but in this case some cores will be unable to load `data`.\n So, it is preferable to fabricate something here instead\n of passing NULL, which will help more cores to succeed.\n retro_system_info::need_fullpath requires\n that this path is valid."]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Memory buffer of loaded game. Will be NULL\n if need_fullpath was set."]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Size of memory buffer."]
    pub size: usize,
    #[doc = " String of implementation specific meta-data."]
    pub meta: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_retro_game_info() {
    const UNINIT: ::std::mem::MaybeUninit<retro_game_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_game_info>(),
        32usize,
        concat!("Size of: ", stringify!(retro_game_info))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_game_info>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_game_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_game_info),
            "::",
            stringify!(meta)
        )
    );
}
#[doc = " The memory in data is cached.\n If not cached, random writes and/or reading from the buffer is expected to be very slow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_framebuffer {
    #[doc = " The framebuffer which the core can render into.\nSet by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER.\nThe initial contents of data are unspecified."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " The framebuffer width used by the core. Set by core."]
    pub width: ::std::os::raw::c_uint,
    #[doc = " The framebuffer height used by the core. Set by core."]
    pub height: ::std::os::raw::c_uint,
    #[doc = " The number of bytes between the beginning of a scanline,\nand beginning of the next scanline.\nSet by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER."]
    pub pitch: usize,
    #[doc = " The pixel format the core must use to render into data.\nThis format could differ from the format used in\nSET_PIXEL_FORMAT.\nSet by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER."]
    pub format: retro_pixel_format,
    #[doc = " How the core will access the memory in the framebuffer.\nRETRO_MEMORY_ACCESS_* flags.\nSet by core."]
    pub access_flags: ::std::os::raw::c_uint,
    #[doc = " Flags telling core how the memory has been mapped.\nRETRO_MEMORY_TYPE_* flags.\nSet by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER."]
    pub memory_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_framebuffer() {
    const UNINIT: ::std::mem::MaybeUninit<retro_framebuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_framebuffer>(),
        40usize,
        concat!("Size of: ", stringify!(retro_framebuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_framebuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_framebuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_framebuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_framebuffer),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_framebuffer),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_framebuffer),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_framebuffer),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_framebuffer),
            "::",
            stringify!(access_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory_flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_framebuffer),
            "::",
            stringify!(memory_flags)
        )
    );
}
#[doc = " Used by a libretro core to override the current\n fastforwarding mode of the frontend"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_fastforwarding_override {
    #[doc = " Specifies the runtime speed multiplier that\n will be applied when 'fastforward' is true.\n For example, a value of 5.0 when running 60 FPS\n content will cap the fast-forward rate at 300 FPS.\n Note that the target multiplier may not be achieved\n if the host hardware has insufficient processing\n power.\n Setting a value of 0.0 (or greater than 0.0 but\n less than 1.0) will result in an uncapped\n fast-forward rate (limited only by hardware\n capacity).\n If the value is negative, it will be ignored\n (i.e. the frontend will use a runtime speed\n multiplier of its own choosing)"]
    pub ratio: f32,
    #[doc = " If true, fastforwarding mode will be enabled.\n If false, fastforwarding mode will be disabled."]
    pub fastforward: bool,
    #[doc = " If true, and if supported by the frontend, an\n on-screen notification will be displayed while\n 'fastforward' is true.\n If false, and if supported by the frontend, any\n on-screen fast-forward notifications will be\n suppressed"]
    pub notification: bool,
    #[doc = " If true, the core will have sole control over\n when fastforwarding mode is enabled/disabled;\n the frontend will not be able to change the\n state set by 'fastforward' until either\n 'inhibit_toggle' is set to false, or the core\n is unloaded"]
    pub inhibit_toggle: bool,
}
#[test]
fn bindgen_test_layout_retro_fastforwarding_override() {
    const UNINIT: ::std::mem::MaybeUninit<retro_fastforwarding_override> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_fastforwarding_override>(),
        8usize,
        concat!("Size of: ", stringify!(retro_fastforwarding_override))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_fastforwarding_override>(),
        4usize,
        concat!("Alignment of ", stringify!(retro_fastforwarding_override))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ratio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_fastforwarding_override),
            "::",
            stringify!(ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fastforward) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_fastforwarding_override),
            "::",
            stringify!(fastforward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notification) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_fastforwarding_override),
            "::",
            stringify!(notification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inhibit_toggle) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_fastforwarding_override),
            "::",
            stringify!(inhibit_toggle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_throttle_state {
    #[doc = " The current throttling mode. Should be one of the values above."]
    pub mode: ::std::os::raw::c_uint,
    #[doc = " How many times per second the frontend aims to call retro_run.\n Depending on the mode, it can be 0 if there is no known fixed rate.\n This won't be accurate if the total processing time of the core and\n the frontend is longer than what is available for one frame."]
    pub rate: f32,
}
#[test]
fn bindgen_test_layout_retro_throttle_state() {
    const UNINIT: ::std::mem::MaybeUninit<retro_throttle_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_throttle_state>(),
        8usize,
        concat!("Size of: ", stringify!(retro_throttle_state))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_throttle_state>(),
        4usize,
        concat!("Alignment of ", stringify!(retro_throttle_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_throttle_state),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_throttle_state),
            "::",
            stringify!(rate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_microphone {
    _unused: [u8; 0],
}
#[doc = " Opaque handle to a microphone that's been opened for use.\n The underlying object is accessed or created with \\c retro_microphone_interface_t."]
pub type retro_microphone_t = retro_microphone;
#[doc = " Parameters for configuring a microphone.\n Some of these might not be honored,\n depending on the available hardware and driver configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_microphone_params {
    #[doc = " The desired sample rate of the microphone's input, in Hz.\n The microphone's input will be resampled,\n so cores can ask for whichever frequency they need.\n\n If zero, some reasonable default will be provided by the frontend\n (usually from its config file).\n\n @see retro_get_mic_rate_t"]
    pub rate: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_retro_microphone_params() {
    const UNINIT: ::std::mem::MaybeUninit<retro_microphone_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_microphone_params>(),
        4usize,
        concat!("Size of: ", stringify!(retro_microphone_params))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_microphone_params>(),
        4usize,
        concat!("Alignment of ", stringify!(retro_microphone_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_params),
            "::",
            stringify!(rate)
        )
    );
}
#[doc = " Parameters for configuring a microphone.\n Some of these might not be honored,\n depending on the available hardware and driver configuration."]
pub type retro_microphone_params_t = retro_microphone_params;
#[doc = " @copydoc retro_microphone_interface::open_mic"]
pub type retro_open_mic_t = ::std::option::Option<
    unsafe extern "C" fn(params: *const retro_microphone_params_t) -> *mut retro_microphone_t,
>;
#[doc = " @copydoc retro_microphone_interface::close_mic"]
pub type retro_close_mic_t =
    ::std::option::Option<unsafe extern "C" fn(microphone: *mut retro_microphone_t)>;
#[doc = " @copydoc retro_microphone_interface::get_params"]
pub type retro_get_mic_params_t = ::std::option::Option<
    unsafe extern "C" fn(
        microphone: *const retro_microphone_t,
        params: *mut retro_microphone_params_t,
    ) -> bool,
>;
#[doc = " @copydoc retro_microphone_interface::set_mic_state"]
pub type retro_set_mic_state_t = ::std::option::Option<
    unsafe extern "C" fn(microphone: *mut retro_microphone_t, state: bool) -> bool,
>;
#[doc = " @copydoc retro_microphone_interface::get_mic_state"]
pub type retro_get_mic_state_t =
    ::std::option::Option<unsafe extern "C" fn(microphone: *const retro_microphone_t) -> bool>;
#[doc = " @copydoc retro_microphone_interface::read_mic"]
pub type retro_read_mic_t = ::std::option::Option<
    unsafe extern "C" fn(
        microphone: *mut retro_microphone_t,
        samples: *mut i16,
        num_samples: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " An interface for querying the microphone and accessing data read from it.\n\n @see RETRO_ENVIRONMENT_GET_MICROPHONE_INTERFACE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_microphone_interface {
    #[doc = " The version of this microphone interface.\n Set by the core to request a particular version,\n and set by the frontend to indicate the returned version.\n 0 indicates that the interface is invalid or uninitialized."]
    pub interface_version: ::std::os::raw::c_uint,
    #[doc = " Initializes a new microphone.\n Assuming that microphone support is enabled and provided by the frontend,\n cores may call this function whenever necessary.\n A microphone could be opened throughout a core's lifetime,\n or it could wait until a microphone is plugged in to the emulated device.\n\n The returned handle will be valid until it's freed,\n even if the audio driver is reinitialized.\n\n This function is not guaranteed to be thread-safe.\n\n @param args[in] Parameters used to create the microphone.\n May be \\c NULL, in which case the default value of each parameter will be used.\n\n @returns Pointer to the newly-opened microphone,\n or \\c NULL if one couldn't be opened.\n This likely means that no microphone is plugged in and recognized,\n or the maximum number of supported microphones has been reached.\n\n @note Microphones are \\em inactive by default;\n to begin capturing audio, call \\c set_mic_state.\n @see retro_microphone_params_t"]
    pub open_mic: retro_open_mic_t,
    #[doc = " Closes a microphone that was initialized with \\c open_mic.\n Calling this function will stop all microphone activity\n and free up the resources that it allocated.\n Afterwards, the handle is invalid and must not be used.\n\n A frontend may close opened microphones when unloading content,\n but this behavior is not guaranteed.\n Cores should close their microphones when exiting, just to be safe.\n\n @param microphone Pointer to the microphone that was allocated by \\c open_mic.\n If \\c NULL, this function does nothing.\n\n @note The handle might be reused if another microphone is opened later."]
    pub close_mic: retro_close_mic_t,
    #[doc = " Returns the configured parameters of this microphone.\n These may differ from what was requested depending on\n the driver and device configuration.\n\n Cores should check these values before they start fetching samples.\n\n Will not change after the mic was opened.\n\n @param microphone[in] Opaque handle to the microphone\n whose parameters will be retrieved.\n @param params[out] The parameters object that the\n microphone's parameters will be copied to.\n\n @return \\c true if the parameters were retrieved,\n \\c false if there was an error."]
    pub get_params: retro_get_mic_params_t,
    #[doc = " Enables or disables the given microphone.\n Microphones are disabled by default\n and must be explicitly enabled before they can be used.\n Disabled microphones will not process incoming audio samples,\n and will therefore have minimal impact on overall performance.\n Cores may enable microphones throughout their lifetime,\n or only for periods where they're needed.\n\n Cores that accept microphone input should be able to operate without it;\n we suggest substituting silence in this case.\n\n @param microphone Opaque handle to the microphone\n whose state will be adjusted.\n This will have been provided by \\c open_mic.\n @param state \\c true if the microphone should receive audio input,\n \\c false if it should be idle.\n @returns \\c true if the microphone's state was successfully set,\n \\c false if \\c microphone is invalid\n or if there was an error."]
    pub set_mic_state: retro_set_mic_state_t,
    #[doc = " Queries the active state of a microphone at the given index.\n Will return whether the microphone is enabled,\n even if the driver is paused.\n\n @param microphone Opaque handle to the microphone\n whose state will be queried.\n @return \\c true if the provided \\c microphone is valid and active,\n \\c false if not or if there was an error."]
    pub get_mic_state: retro_get_mic_state_t,
    #[doc = " Retrieves the input processed by the microphone since the last call.\n \\em Must be called every frame unless \\c microphone is disabled,\n similar to how \\c retro_audio_sample_batch_t works.\n\n @param[in] microphone Opaque handle to the microphone\n whose recent input will be retrieved.\n @param[out] samples The buffer that will be used to store the microphone's data.\n Microphone input is in mono (i.e. one number per sample).\n Should be large enough to accommodate the expected number of samples per frame;\n for example, a 44.1kHz sample rate at 60 FPS would require space for 735 samples.\n @param[in] num_samples The size of the data buffer in samples (\\em not bytes).\n Microphone input is in mono, so a \"frame\" and a \"sample\" are equivalent in length here.\n\n @return The number of samples that were copied into \\c samples.\n If \\c microphone is pending driver initialization,\n this function will copy silence of the requested length into \\c samples.\n\n Will return -1 if the microphone is disabled,\n the audio driver is paused,\n or there was an error."]
    pub read_mic: retro_read_mic_t,
}
#[test]
fn bindgen_test_layout_retro_microphone_interface() {
    const UNINIT: ::std::mem::MaybeUninit<retro_microphone_interface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_microphone_interface>(),
        56usize,
        concat!("Size of: ", stringify!(retro_microphone_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_microphone_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(retro_microphone_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_interface),
            "::",
            stringify!(interface_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_mic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_interface),
            "::",
            stringify!(open_mic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_mic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_interface),
            "::",
            stringify!(close_mic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_interface),
            "::",
            stringify!(get_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_mic_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_interface),
            "::",
            stringify!(set_mic_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mic_state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_interface),
            "::",
            stringify!(get_mic_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_mic) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_microphone_interface),
            "::",
            stringify!(read_mic)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Describes how a device is being powered.\n @see RETRO_ENVIRONMENT_GET_DEVICE_POWER"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum retro_power_state {
    #[doc = " Indicates that the frontend cannot report its power state at this time,\n most likely due to a lack of support.\n\n \\c RETRO_ENVIRONMENT_GET_DEVICE_POWER will not return this value;\n instead, the environment callback will return \\c false."]
    RETRO_POWERSTATE_UNKNOWN = 0,
    #[doc = " Indicates that the device is running on its battery.\n Usually applies to portable devices such as handhelds, laptops, and smartphones."]
    RETRO_POWERSTATE_DISCHARGING = 1,
    #[doc = " Indicates that the device's battery is currently charging."]
    RETRO_POWERSTATE_CHARGING = 2,
    #[doc = " Indicates that the device is connected to a power source\n and that its battery has finished charging."]
    RETRO_POWERSTATE_CHARGED = 3,
    #[doc = " Indicates that the device is connected to a power source\n and that it does not have a battery.\n This usually suggests a desktop computer or a non-portable game console."]
    RETRO_POWERSTATE_PLUGGED_IN = 4,
}
#[doc = " Describes the power state of the device running the frontend.\n @see RETRO_ENVIRONMENT_GET_DEVICE_POWER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct retro_device_power {
    #[doc = " The current state of the frontend's power usage."]
    pub state: retro_power_state,
    #[doc = " A rough estimate of the amount of time remaining (in seconds)\n before the device powers off.\n This value depends on a variety of factors,\n so it is not guaranteed to be accurate.\n\n Will be set to \\c RETRO_POWERSTATE_NO_ESTIMATE if \\c state does not equal \\c RETRO_POWERSTATE_DISCHARGING.\n May still be set to \\c RETRO_POWERSTATE_NO_ESTIMATE if the frontend is unable to provide an estimate."]
    pub seconds: ::std::os::raw::c_int,
    #[doc = " The approximate percentage of battery charge,\n ranging from 0 to 100 (inclusive).\n The device may power off before this reaches 0.\n\n The user might have configured their device\n to stop charging before the battery is full,\n so do not assume that this will be 100 in the \\c RETRO_POWERSTATE_CHARGED state."]
    pub percent: i8,
}
#[test]
fn bindgen_test_layout_retro_device_power() {
    const UNINIT: ::std::mem::MaybeUninit<retro_device_power> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<retro_device_power>(),
        12usize,
        concat!("Size of: ", stringify!(retro_device_power))
    );
    assert_eq!(
        ::std::mem::align_of::<retro_device_power>(),
        4usize,
        concat!("Alignment of ", stringify!(retro_device_power))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_device_power),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_device_power),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(retro_device_power),
            "::",
            stringify!(percent)
        )
    );
}
#[doc = " Environment callback. Gives implementations a way of performing\n uncommon tasks. Extensible."]
pub type retro_environment_t = ::std::option::Option<
    unsafe extern "C" fn(cmd: ::std::os::raw::c_uint, data: *mut ::std::os::raw::c_void) -> bool,
>;
#[doc = " Render a frame. Pixel format is 15-bit 0RGB1555 native endian\n unless changed (see RETRO_ENVIRONMENT_SET_PIXEL_FORMAT).\n\n Width and height specify dimensions of buffer.\n Pitch specifices length in bytes between two lines in buffer.\n\n For performance reasons, it is highly recommended to have a frame\n that is packed in memory, i.e. pitch == width * byte_per_pixel.\n Certain graphic APIs, such as OpenGL ES, do not like textures\n that are not packed in memory."]
pub type retro_video_refresh_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_void,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        pitch: usize,
    ),
>;
#[doc = " Renders a single audio frame. Should only be used if implementation\n generates a single sample at a time.\n Format is signed 16-bit native endian."]
pub type retro_audio_sample_t = ::std::option::Option<unsafe extern "C" fn(left: i16, right: i16)>;
#[doc = " Renders multiple audio frames in one go.\n\n One frame is defined as a sample of left and right channels, interleaved.\n I.e. int16_t buf[4] = { l, r, l, r }; would be 2 frames.\n Only one of the audio callbacks must ever be used."]
pub type retro_audio_sample_batch_t =
    ::std::option::Option<unsafe extern "C" fn(data: *const i16, frames: usize) -> usize>;
#[doc = " Polls input."]
pub type retro_input_poll_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Queries for input for player 'port'. device will be masked with\n RETRO_DEVICE_MASK.\n\n Specialization of devices such as RETRO_DEVICE_JOYPAD_MULTITAP that\n have been set with retro_set_controller_port_device()\n will still use the higher level RETRO_DEVICE_JOYPAD to request input."]
pub type retro_input_state_t = ::std::option::Option<
    unsafe extern "C" fn(
        port: ::std::os::raw::c_uint,
        device: ::std::os::raw::c_uint,
        index: ::std::os::raw::c_uint,
        id: ::std::os::raw::c_uint,
    ) -> i16,
>;
extern crate libloading;
pub struct LibretroRaw {
    __library: ::libloading::Library,
    pub retro_set_environment: unsafe extern "C" fn(arg1: retro_environment_t),
    pub retro_set_video_refresh: unsafe extern "C" fn(arg1: retro_video_refresh_t),
    pub retro_set_audio_sample: unsafe extern "C" fn(arg1: retro_audio_sample_t),
    pub retro_set_audio_sample_batch: unsafe extern "C" fn(arg1: retro_audio_sample_batch_t),
    pub retro_set_input_poll: unsafe extern "C" fn(arg1: retro_input_poll_t),
    pub retro_set_input_state: unsafe extern "C" fn(arg1: retro_input_state_t),
    pub retro_init: unsafe extern "C" fn(),
    pub retro_deinit: unsafe extern "C" fn(),
    pub retro_api_version: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub retro_get_system_info: unsafe extern "C" fn(info: *mut retro_system_info),
    pub retro_get_system_av_info: unsafe extern "C" fn(info: *mut retro_system_av_info),
    pub retro_set_controller_port_device:
        unsafe extern "C" fn(port: ::std::os::raw::c_uint, device: ::std::os::raw::c_uint),
    pub retro_reset: unsafe extern "C" fn(),
    pub retro_run: unsafe extern "C" fn(),
    pub retro_serialize_size: unsafe extern "C" fn() -> usize,
    pub retro_serialize:
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, size: usize) -> bool,
    pub retro_unserialize:
        unsafe extern "C" fn(data: *const ::std::os::raw::c_void, size: usize) -> bool,
    pub retro_cheat_reset: unsafe extern "C" fn(),
    pub retro_cheat_set: unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        enabled: bool,
        code: *const ::std::os::raw::c_char,
    ),
    pub retro_load_game: unsafe extern "C" fn(game: *const retro_game_info) -> bool,
    pub retro_load_game_special: unsafe extern "C" fn(
        game_type: ::std::os::raw::c_uint,
        info: *const retro_game_info,
        num_info: usize,
    ) -> bool,
    pub retro_unload_game: unsafe extern "C" fn(),
    pub retro_get_region: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub retro_get_memory_data:
        unsafe extern "C" fn(id: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void,
    pub retro_get_memory_size: unsafe extern "C" fn(id: ::std::os::raw::c_uint) -> usize,
}
impl LibretroRaw {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let retro_set_environment = __library.get(b"retro_set_environment\0").map(|sym| *sym)?;
        let retro_set_video_refresh = __library
            .get(b"retro_set_video_refresh\0")
            .map(|sym| *sym)?;
        let retro_set_audio_sample = __library.get(b"retro_set_audio_sample\0").map(|sym| *sym)?;
        let retro_set_audio_sample_batch = __library
            .get(b"retro_set_audio_sample_batch\0")
            .map(|sym| *sym)?;
        let retro_set_input_poll = __library.get(b"retro_set_input_poll\0").map(|sym| *sym)?;
        let retro_set_input_state = __library.get(b"retro_set_input_state\0").map(|sym| *sym)?;
        let retro_init = __library.get(b"retro_init\0").map(|sym| *sym)?;
        let retro_deinit = __library.get(b"retro_deinit\0").map(|sym| *sym)?;
        let retro_api_version = __library.get(b"retro_api_version\0").map(|sym| *sym)?;
        let retro_get_system_info = __library.get(b"retro_get_system_info\0").map(|sym| *sym)?;
        let retro_get_system_av_info = __library
            .get(b"retro_get_system_av_info\0")
            .map(|sym| *sym)?;
        let retro_set_controller_port_device = __library
            .get(b"retro_set_controller_port_device\0")
            .map(|sym| *sym)?;
        let retro_reset = __library.get(b"retro_reset\0").map(|sym| *sym)?;
        let retro_run = __library.get(b"retro_run\0").map(|sym| *sym)?;
        let retro_serialize_size = __library.get(b"retro_serialize_size\0").map(|sym| *sym)?;
        let retro_serialize = __library.get(b"retro_serialize\0").map(|sym| *sym)?;
        let retro_unserialize = __library.get(b"retro_unserialize\0").map(|sym| *sym)?;
        let retro_cheat_reset = __library.get(b"retro_cheat_reset\0").map(|sym| *sym)?;
        let retro_cheat_set = __library.get(b"retro_cheat_set\0").map(|sym| *sym)?;
        let retro_load_game = __library.get(b"retro_load_game\0").map(|sym| *sym)?;
        let retro_load_game_special = __library
            .get(b"retro_load_game_special\0")
            .map(|sym| *sym)?;
        let retro_unload_game = __library.get(b"retro_unload_game\0").map(|sym| *sym)?;
        let retro_get_region = __library.get(b"retro_get_region\0").map(|sym| *sym)?;
        let retro_get_memory_data = __library.get(b"retro_get_memory_data\0").map(|sym| *sym)?;
        let retro_get_memory_size = __library.get(b"retro_get_memory_size\0").map(|sym| *sym)?;
        Ok(LibretroRaw {
            __library,
            retro_set_environment,
            retro_set_video_refresh,
            retro_set_audio_sample,
            retro_set_audio_sample_batch,
            retro_set_input_poll,
            retro_set_input_state,
            retro_init,
            retro_deinit,
            retro_api_version,
            retro_get_system_info,
            retro_get_system_av_info,
            retro_set_controller_port_device,
            retro_reset,
            retro_run,
            retro_serialize_size,
            retro_serialize,
            retro_unserialize,
            retro_cheat_reset,
            retro_cheat_set,
            retro_load_game,
            retro_load_game_special,
            retro_unload_game,
            retro_get_region,
            retro_get_memory_data,
            retro_get_memory_size,
        })
    }
    #[doc = " Sets callbacks. retro_set_environment() is guaranteed to be called\n before retro_init().\n\n The rest of the set_* functions are guaranteed to have been called\n before the first call to retro_run() is made."]
    pub unsafe fn retro_set_environment(&self, arg1: retro_environment_t) {
        (self.retro_set_environment)(arg1)
    }
    pub unsafe fn retro_set_video_refresh(&self, arg1: retro_video_refresh_t) {
        (self.retro_set_video_refresh)(arg1)
    }
    pub unsafe fn retro_set_audio_sample(&self, arg1: retro_audio_sample_t) {
        (self.retro_set_audio_sample)(arg1)
    }
    pub unsafe fn retro_set_audio_sample_batch(&self, arg1: retro_audio_sample_batch_t) {
        (self.retro_set_audio_sample_batch)(arg1)
    }
    pub unsafe fn retro_set_input_poll(&self, arg1: retro_input_poll_t) {
        (self.retro_set_input_poll)(arg1)
    }
    pub unsafe fn retro_set_input_state(&self, arg1: retro_input_state_t) {
        (self.retro_set_input_state)(arg1)
    }
    #[doc = " Library global initialization/deinitialization."]
    pub unsafe fn retro_init(&self) {
        (self.retro_init)()
    }
    pub unsafe fn retro_deinit(&self) {
        (self.retro_deinit)()
    }
    #[doc = " Must return RETRO_API_VERSION. Used to validate ABI compatibility\n when the API is revised."]
    pub unsafe fn retro_api_version(&self) -> ::std::os::raw::c_uint {
        (self.retro_api_version)()
    }
    #[doc = " Gets statically known system info. Pointers provided in *info\n must be statically allocated.\n Can be called at any time, even before retro_init()."]
    pub unsafe fn retro_get_system_info(&self, info: *mut retro_system_info) {
        (self.retro_get_system_info)(info)
    }
    #[doc = " Gets information about system audio/video timings and geometry.\n Can be called only after retro_load_game() has successfully completed.\n NOTE: The implementation of this function might not initialize every\n variable if needed.\n E.g. geom.aspect_ratio might not be initialized if core doesn't\n desire a particular aspect ratio."]
    pub unsafe fn retro_get_system_av_info(&self, info: *mut retro_system_av_info) {
        (self.retro_get_system_av_info)(info)
    }
    #[doc = " Sets device to be used for player 'port'.\n By default, RETRO_DEVICE_JOYPAD is assumed to be plugged into all\n available ports.\n Setting a particular device type is not a guarantee that libretro cores\n will only poll input based on that particular device type. It is only a\n hint to the libretro core when a core cannot automatically detect the\n appropriate input device type on its own. It is also relevant when a\n core can change its behavior depending on device type.\n\n As part of the core's implementation of retro_set_controller_port_device,\n the core should call RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS to notify the\n frontend if the descriptions for any controls have changed as a\n result of changing the device type."]
    pub unsafe fn retro_set_controller_port_device(
        &self,
        port: ::std::os::raw::c_uint,
        device: ::std::os::raw::c_uint,
    ) {
        (self.retro_set_controller_port_device)(port, device)
    }
    #[doc = " Resets the current game."]
    pub unsafe fn retro_reset(&self) {
        (self.retro_reset)()
    }
    #[doc = " Runs the game for one video frame.\n During retro_run(), input_poll callback must be called at least once.\n\n If a frame is not rendered for reasons where a game \"dropped\" a frame,\n this still counts as a frame, and retro_run() should explicitly dupe\n a frame if GET_CAN_DUPE returns true.\n In this case, the video callback can take a NULL argument for data."]
    pub unsafe fn retro_run(&self) {
        (self.retro_run)()
    }
    #[doc = " Returns the amount of data the implementation requires to serialize\n internal state (save states).\n Between calls to retro_load_game() and retro_unload_game(), the\n returned size is never allowed to be larger than a previous returned\n value, to ensure that the frontend can allocate a save state buffer once."]
    pub unsafe fn retro_serialize_size(&self) -> usize {
        (self.retro_serialize_size)()
    }
    #[doc = " Serializes internal state. If failed, or size is lower than\n retro_serialize_size(), it should return false, true otherwise."]
    pub unsafe fn retro_serialize(&self, data: *mut ::std::os::raw::c_void, size: usize) -> bool {
        (self.retro_serialize)(data, size)
    }
    pub unsafe fn retro_unserialize(
        &self,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> bool {
        (self.retro_unserialize)(data, size)
    }
    pub unsafe fn retro_cheat_reset(&self) {
        (self.retro_cheat_reset)()
    }
    pub unsafe fn retro_cheat_set(
        &self,
        index: ::std::os::raw::c_uint,
        enabled: bool,
        code: *const ::std::os::raw::c_char,
    ) {
        (self.retro_cheat_set)(index, enabled, code)
    }
    #[doc = " Loads a game.\n Return true to indicate successful loading and false to indicate load failure."]
    pub unsafe fn retro_load_game(&self, game: *const retro_game_info) -> bool {
        (self.retro_load_game)(game)
    }
    #[doc = " Loads a \"special\" kind of game. Should not be used,\n except in extreme cases."]
    pub unsafe fn retro_load_game_special(
        &self,
        game_type: ::std::os::raw::c_uint,
        info: *const retro_game_info,
        num_info: usize,
    ) -> bool {
        (self.retro_load_game_special)(game_type, info, num_info)
    }
    #[doc = " Unloads the currently loaded game. Called before retro_deinit(void)."]
    pub unsafe fn retro_unload_game(&self) {
        (self.retro_unload_game)()
    }
    #[doc = " Gets region of game."]
    pub unsafe fn retro_get_region(&self) -> ::std::os::raw::c_uint {
        (self.retro_get_region)()
    }
    #[doc = " Gets region of memory."]
    pub unsafe fn retro_get_memory_data(
        &self,
        id: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void {
        (self.retro_get_memory_data)(id)
    }
    pub unsafe fn retro_get_memory_size(&self, id: ::std::os::raw::c_uint) -> usize {
        (self.retro_get_memory_size)(id)
    }
}
